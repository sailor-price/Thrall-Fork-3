// assembly_valheim, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null
// ItemDrop.ItemData
using System;
using System.Collections.Generic;
using System.Text;
using UnityEngine;

[Serializable]
public class ItemData
{
	public enum ItemType
	{
		None = 0,
		Material = 1,
		Consumable = 2,
		OneHandedWeapon = 3,
		Bow = 4,
		Shield = 5,
		Helmet = 6,
		Chest = 7,
		Ammo = 9,
		Customization = 10,
		Legs = 11,
		Hands = 12,
		Trophy = 13,
		TwoHandedWeapon = 14,
		Torch = 15,
		Misc = 16,
		Shoulder = 17,
		Utility = 18,
		Tool = 19,
		Attach_Atgeir = 20,
		Fish = 21,
		TwoHandedWeaponLeft = 22,
		AmmoNonEquipable = 23,
		Trinket = 24
	}

	public enum AnimationState
	{
		Unarmed,
		OneHanded,
		TwoHandedClub,
		Bow,
		Shield,
		Torch,
		LeftTorch,
		Atgeir,
		TwoHandedAxe,
		FishingRod,
		Crossbow,
		Knives,
		Staves,
		Greatsword,
		MagicItem,
		DualAxes,
		Feaster,
		Scythe
	}

	public enum AiTarget
	{
		Enemy,
		FriendHurt,
		Friend
	}

	public enum HelmetHairType
	{
		Default,
		Hidden,
		HiddenHat,
		HiddenHood,
		HiddenNeck,
		HiddenScarf
	}

	public enum AccessoryType
	{
		Hair,
		Beard
	}

	[Serializable]
	public class HelmetHairSettings
	{
		public HelmetHairType m_setting;

		public ItemDrop m_hairPrefab;
	}

	[Serializable]
	public class SharedData
	{
		public string m_name = "";

		public string m_subtitle = "";

		public string m_dlc = "";

		public ItemType m_itemType = ItemType.Misc;

		public Sprite[] m_icons = Array.Empty<Sprite>();

		public ItemType m_attachOverride;

		[TextArea]
		public string m_description = "";

		public int m_maxStackSize = 1;

		public bool m_autoStack = true;

		public int m_maxQuality = 1;

		public float m_scaleByQuality;

		public float m_weight = 1f;

		public float m_scaleWeightByQuality;

		public int m_value;

		public bool m_teleportable = true;

		public bool m_questItem;

		public float m_equipDuration = 1f;

		public int m_variants;

		public Vector2Int m_trophyPos = Vector2Int.zero;

		public PieceTable m_buildPieces;

		public bool m_centerCamera;

		public string m_setName = "";

		public int m_setSize;

		public StatusEffect m_setStatusEffect;

		public StatusEffect m_equipStatusEffect;

		[Header("Stat modifiers")]
		public float m_eitrRegenModifier;

		public float m_movementModifier;

		public float m_homeItemsStaminaModifier;

		public float m_heatResistanceModifier;

		public float m_jumpStaminaModifier;

		public float m_attackStaminaModifier;

		public float m_blockStaminaModifier;

		public float m_dodgeStaminaModifier;

		public float m_swimStaminaModifier;

		public float m_sneakStaminaModifier;

		public float m_runStaminaModifier;

		[Header("Food settings")]
		public float m_food;

		public float m_foodStamina;

		public float m_foodEitr;

		public float m_foodBurnTime;

		public float m_foodRegen;

		public float m_foodEatAnimTime = 1f;

		public bool m_isDrink;

		[Header("Armor settings")]
		public Material m_armorMaterial;

		public HelmetHairType m_helmetHideHair = HelmetHairType.Hidden;

		public HelmetHairType m_helmetHideBeard;

		public List<HelmetHairSettings> m_helmetHairSettings = new List<HelmetHairSettings>();

		public List<HelmetHairSettings> m_helmetBeardSettings = new List<HelmetHairSettings>();

		public float m_armor = 10f;

		public float m_armorPerLevel = 1f;

		public List<HitData.DamageModPair> m_damageModifiers = new List<HitData.DamageModPair>();

		[Header("Shield settings")]
		public float m_blockPower = 10f;

		public float m_blockPowerPerLevel;

		public float m_deflectionForce;

		public float m_deflectionForcePerLevel;

		public float m_timedBlockBonus = 1.5f;

		public float m_perfectBlockStaminaRegen;

		public StatusEffect m_perfectBlockStatusEffect;

		[Space(8f)]
		public bool m_buildBlockCharges;

		public int m_maxBlockCharges = 5;

		public float m_blockChargeDecayTime = 1f;

		public float m_blockChargeBlockingDecayMult = 0.25f;

		public EffectList m_blockChargeEffects = new EffectList();

		[Header("Adrenaline")]
		public float m_maxAdrenaline;

		public StatusEffect m_fullAdrenalineSE;

		public float m_blockAdrenaline = 2f;

		public float m_perfectBlockAdrenaline = 5f;

		[Header("Weapon")]
		public AnimationState m_animationState = AnimationState.OneHanded;

		public Skills.SkillType m_skillType = Skills.SkillType.Swords;

		public int m_toolTier;

		public HitData.DamageTypes m_damages;

		public HitData.DamageTypes m_damagesPerLevel;

		public float m_attackForce = 30f;

		public float m_backstabBonus = 4f;

		public bool m_dodgeable;

		public bool m_blockable;

		public bool m_tamedOnly;

		public bool m_alwaysRotate;

		public StatusEffect m_attackStatusEffect;

		public float m_attackStatusEffectChance = 1f;

		public GameObject m_spawnOnHit;

		public GameObject m_spawnOnHitTerrain;

		public bool m_projectileToolTip = true;

		[Header("Ammo")]
		public string m_ammoType = "";

		[Header("Attacks")]
		public Attack m_attack;

		public Attack m_secondaryAttack;

		[Header("ItemStand")]
		[Tooltip("* Specifies offsets from the attach base\n* base attach is used as default for both if no settings exist\n* if there is a single setting, it will be used as default for instead\n* any additional settings will enable cycling of orientations for that itemstand")]
		public List<ItemStand.OrientationSettings> m_itemStandOffsets = new List<ItemStand.OrientationSettings>();

		[Header("Durability")]
		public bool m_useDurability;

		public bool m_destroyBroken = true;

		public bool m_canBeReparied = true;

		public float m_maxDurability = 100f;

		public float m_durabilityPerLevel = 50f;

		public float m_useDurabilityDrain = 1f;

		public float m_durabilityDrain;

		public Skills.SkillType m_placementDurabilitySkill;

		public float m_placementDurabilityMax = 0.5f;

		[Header("AI")]
		public float m_aiAttackRange = 2f;

		public float m_aiAttackRangeMin;

		public float m_aiAttackInterval = 2f;

		public float m_aiAttackMaxAngle = 5f;

		public bool m_aiInvertAngleCheck;

		public bool m_aiWhenFlying = true;

		public float m_aiWhenFlyingAltitudeMin;

		public float m_aiWhenFlyingAltitudeMax = 999999f;

		public bool m_aiWhenWalking = true;

		public bool m_aiWhenSwiming = true;

		public bool m_aiPrioritized;

		public bool m_aiInDungeonOnly;

		public bool m_aiInMistOnly;

		[Range(0f, 1f)]
		public float m_aiMaxHealthPercentage = 1f;

		[Range(0f, 1f)]
		public float m_aiMinHealthPercentage;

		public AiTarget m_aiTargetType;

		[Header("Effects")]
		public EffectList m_hitEffect = new EffectList();

		public EffectList m_hitTerrainEffect = new EffectList();

		public EffectList m_blockEffect = new EffectList();

		public EffectList m_startEffect = new EffectList();

		public EffectList m_holdStartEffect = new EffectList();

		public EffectList m_equipEffect = new EffectList();

		public EffectList m_unequipEffect = new EffectList();

		public EffectList m_triggerEffect = new EffectList();

		public EffectList m_trailStartEffect = new EffectList();

		public EffectList m_buildEffect = new EffectList();

		public EffectList m_destroyEffect = new EffectList();

		[Header("Consumable")]
		public StatusEffect m_consumeStatusEffect;

		public ItemDrop m_appendToolTip;

		public override string ToString()
		{
			return string.Format("{0}: {1}, max stack: {2}, attacks: {3} / {4}", "SharedData", m_name, m_maxStackSize, m_attack, m_secondaryAttack);
		}
	}

	private static StringBuilder m_stringBuilder = new StringBuilder(256);

	public int m_stack = 1;

	public float m_durability = 100f;

	public int m_quality = 1;

	public int m_variant;

	public int m_worldLevel = Game.m_worldLevel;

	public bool m_pickedUp;

	public SharedData m_shared;

	[NonSerialized]
	public long m_crafterID;

	[NonSerialized]
	public string m_crafterName = "";

	[NonSerialized]
	public Dictionary<string, string> m_customData = new Dictionary<string, string>();

	[NonSerialized]
	public Vector2i m_gridPos = Vector2i.zero;

	[NonSerialized]
	public bool m_equipped;

	[NonSerialized]
	public GameObject m_dropPrefab;

	[NonSerialized]
	public float m_lastAttackTime;

	[NonSerialized]
	public GameObject m_lastProjectile;

	public ItemData Clone()
	{
		ItemData obj = MemberwiseClone() as ItemData;
		obj.m_customData = new Dictionary<string, string>(m_customData);
		return obj;
	}

	public bool IsEquipable()
	{
		if (m_shared.m_itemType != ItemType.Tool && m_shared.m_itemType != ItemType.OneHandedWeapon && m_shared.m_itemType != ItemType.TwoHandedWeapon && m_shared.m_itemType != ItemType.TwoHandedWeaponLeft && m_shared.m_itemType != ItemType.Bow && m_shared.m_itemType != ItemType.Shield && m_shared.m_itemType != ItemType.Helmet && m_shared.m_itemType != ItemType.Chest && m_shared.m_itemType != ItemType.Legs && m_shared.m_itemType != ItemType.Shoulder && m_shared.m_itemType != ItemType.Ammo && m_shared.m_itemType != ItemType.Torch && m_shared.m_itemType != ItemType.Utility)
		{
			return m_shared.m_itemType == ItemType.Trinket;
		}
		return true;
	}

	public bool IsWeapon()
	{
		if (m_shared.m_itemType != ItemType.OneHandedWeapon && m_shared.m_itemType != ItemType.Bow && m_shared.m_itemType != ItemType.TwoHandedWeapon && m_shared.m_itemType != ItemType.TwoHandedWeaponLeft)
		{
			return m_shared.m_itemType == ItemType.Torch;
		}
		return true;
	}

	public bool IsTwoHanded()
	{
		if (m_shared.m_itemType != ItemType.TwoHandedWeapon && m_shared.m_itemType != ItemType.TwoHandedWeaponLeft)
		{
			return m_shared.m_itemType == ItemType.Bow;
		}
		return true;
	}

	public bool HavePrimaryAttack()
	{
		return !string.IsNullOrEmpty(m_shared.m_attack.m_attackAnimation);
	}

	public bool HaveSecondaryAttack()
	{
		return !string.IsNullOrEmpty(m_shared.m_secondaryAttack.m_attackAnimation);
	}

	public float GetArmor()
	{
		return GetArmor(m_quality, m_worldLevel);
	}

	public float GetArmor(int quality, float worldLevel)
	{
		return m_shared.m_armor + (float)Mathf.Max(0, quality - 1) * m_shared.m_armorPerLevel + worldLevel * (float)Game.instance.m_worldLevelGearBaseAC;
	}

	public bool TryGetArmorDifference(out float difference)
	{
		if (Player.m_localPlayer != null)
		{
			return Player.m_localPlayer.TryGetArmorDifference(this, out difference);
		}
		difference = 0f;
		return false;
	}

	public int GetValue()
	{
		return m_shared.m_value * m_stack;
	}

	public float GetWeight(int stackOverride = -1)
	{
		int num = ((stackOverride >= 0) ? stackOverride : m_stack);
		float num2 = m_shared.m_weight * (float)num;
		if (m_shared.m_scaleWeightByQuality != 0f && m_quality != 1)
		{
			num2 += num2 * (float)(m_quality - 1) * m_shared.m_scaleWeightByQuality;
		}
		return num2;
	}

	public float GetNonStackedWeight()
	{
		float num = m_shared.m_weight;
		if (m_shared.m_scaleWeightByQuality != 0f && m_quality != 1)
		{
			num += num * (float)(m_quality - 1) * m_shared.m_scaleWeightByQuality;
		}
		return num;
	}

	public HitData.DamageTypes GetDamage()
	{
		return GetDamage(m_quality, m_worldLevel);
	}

	public float GetDurabilityPercentage()
	{
		float maxDurability = GetMaxDurability();
		if (maxDurability == 0f)
		{
			return 1f;
		}
		return Mathf.Clamp01(m_durability / maxDurability);
	}

	public float GetMaxDurability()
	{
		return GetMaxDurability(m_quality);
	}

	public float GetMaxDurability(int quality)
	{
		return m_shared.m_maxDurability + (float)Mathf.Max(0, quality - 1) * m_shared.m_durabilityPerLevel;
	}

	public HitData.DamageTypes GetDamage(int quality, float worldLevel)
	{
		HitData.DamageTypes damages = m_shared.m_damages;
		if (quality > 1)
		{
			damages.Add(m_shared.m_damagesPerLevel, quality - 1);
		}
		if (worldLevel > 0f)
		{
			damages.IncreaseEqually(worldLevel * (float)Game.instance.m_worldLevelGearBaseDamage, seperateUtilityDamage: true);
		}
		return damages;
	}

	public float GetBaseBlockPower()
	{
		return GetBaseBlockPower(m_quality);
	}

	public float GetBaseBlockPower(int quality)
	{
		return m_shared.m_blockPower + (float)Mathf.Max(0, quality - 1) * m_shared.m_blockPowerPerLevel;
	}

	public float GetBlockPower(float skillFactor)
	{
		return GetBlockPower(m_quality, skillFactor);
	}

	public float GetBlockPower(int quality, float skillFactor)
	{
		float baseBlockPower = GetBaseBlockPower(quality);
		return baseBlockPower + baseBlockPower * skillFactor * 0.5f;
	}

	public float GetBlockPowerTooltip(int quality)
	{
		if (Player.m_localPlayer == null)
		{
			return 0f;
		}
		float skillFactor = Player.m_localPlayer.GetSkillFactor(Skills.SkillType.Blocking);
		return GetBlockPower(quality, skillFactor);
	}

	public float GetDrawStaminaDrain()
	{
		if (m_shared.m_attack.m_drawStaminaDrain <= 0f)
		{
			return 0f;
		}
		float drawStaminaDrain = m_shared.m_attack.m_drawStaminaDrain;
		float skillFactor = Player.m_localPlayer.GetSkillFactor(m_shared.m_skillType);
		return drawStaminaDrain - drawStaminaDrain * 0.33f * skillFactor;
	}

	public float GetDrawEitrDrain()
	{
		if (m_shared.m_attack.m_drawEitrDrain <= 0f)
		{
			return 0f;
		}
		float drawEitrDrain = m_shared.m_attack.m_drawEitrDrain;
		float skillFactor = Player.m_localPlayer.GetSkillFactor(m_shared.m_skillType);
		return drawEitrDrain - drawEitrDrain * 0.33f * skillFactor;
	}

	public float GetWeaponLoadingTime()
	{
		if (m_shared.m_attack.m_requiresReload)
		{
			float skillFactor = Player.m_localPlayer.GetSkillFactor(m_shared.m_skillType);
			return Mathf.Lerp(m_shared.m_attack.m_reloadTime, m_shared.m_attack.m_reloadTime * 0.5f, skillFactor);
		}
		return 1f;
	}

	public float GetDeflectionForce()
	{
		return GetDeflectionForce(m_quality);
	}

	public float GetDeflectionForce(int quality)
	{
		return m_shared.m_deflectionForce + (float)Mathf.Max(0, quality - 1) * m_shared.m_deflectionForcePerLevel;
	}

	public Vector3 GetScale()
	{
		return GetScale(m_quality);
	}

	public Vector3 GetScale(float quality)
	{
		float num = 1f + (quality - 1f) * m_shared.m_scaleByQuality;
		return new Vector3(num, num, num);
	}

	public string GetTooltip(int stackOverride = -1)
	{
		return GetTooltip(this, m_quality, crafting: false, m_worldLevel, stackOverride);
	}

	public Sprite GetIcon()
	{
		return m_shared.m_icons[m_variant];
	}

	private static void AddHandedTip(ItemData item, StringBuilder text)
	{
		switch (item.m_shared.m_itemType)
		{
		case ItemType.OneHandedWeapon:
		case ItemType.Shield:
		case ItemType.Torch:
			text.Append("\n$item_onehanded");
			break;
		case ItemType.Bow:
		case ItemType.TwoHandedWeapon:
		case ItemType.Tool:
		case ItemType.TwoHandedWeaponLeft:
			text.Append("\n$item_twohanded");
			break;
		}
	}

	private static void AddBlockTooltip(ItemData item, int qualityLevel, StringBuilder text)
	{
		float baseBlockPower = item.GetBaseBlockPower(qualityLevel);
		if (baseBlockPower > 1f)
		{
			text.AppendFormat("\n$item_blockarmor: <color=orange>{0}</color> <color=yellow>({1})</color>", baseBlockPower, item.GetBlockPowerTooltip(qualityLevel).ToString("0"));
		}
		float deflectionForce = item.GetDeflectionForce(qualityLevel);
		if (deflectionForce > 1f)
		{
			text.AppendFormat("\n$item_blockforce: <color=orange>{0}</color>", deflectionForce);
		}
		if (item.m_shared.m_timedBlockBonus > 1f)
		{
			text.AppendFormat("\n$item_parrybonus: <color=orange>{0}x</color>", item.m_shared.m_timedBlockBonus);
		}
		if (item.m_shared.m_perfectBlockAdrenaline > 0f)
		{
			text.AppendFormat("\n$item_parryadrenaline: <color=orange>{0}</color>", item.m_shared.m_perfectBlockAdrenaline);
		}
		string damageModifiersTooltipString = SE_Stats.GetDamageModifiersTooltipString(item.m_shared.m_damageModifiers);
		if (damageModifiersTooltipString.Length > 0)
		{
			text.Append(damageModifiersTooltipString);
		}
	}

	public static string GetTooltip(ItemData item, int qualityLevel, bool crafting, float worldLevel, int stackOverride = -1)
	{
		Player player = Player.m_localPlayer;
		m_stringBuilder.Clear();
		m_stringBuilder.Append(item.m_shared.m_description);
		m_stringBuilder.Append("\n");
		if (item.m_shared.m_dlc.Length > 0)
		{
			m_stringBuilder.Append("\n<color=#00FFFF>$item_dlc</color>");
		}
		if (item.m_worldLevel > 0)
		{
			m_stringBuilder.Append("\n<color=orange>$item_newgameplusitem " + ((item.m_worldLevel != 1) ? item.m_worldLevel.ToString() : "") + "</color>");
		}
		if (item.m_shared.m_subtitle.Length > 0)
		{
			m_stringBuilder.Append("\n<color=orange>" + item.m_shared.m_subtitle + "</color>");
		}
		AddHandedTip(item, m_stringBuilder);
		if (item.m_crafterID != 0L)
		{
			m_stringBuilder.AppendFormat("\n$item_crafter: <color=orange>{0}</color>", CensorShittyWords.FilterUGC(item.m_crafterName, UGCType.CharacterName, item.m_crafterID));
		}
		if (!item.m_shared.m_teleportable && !ZoneSystem.instance.GetGlobalKey(GlobalKeys.TeleportAll))
		{
			m_stringBuilder.Append("\n<color=orange>$item_noteleport</color>");
		}
		if (item.m_shared.m_value > 0)
		{
			m_stringBuilder.AppendFormat("\n$item_value: <color=orange>{0} ({1} $item_total)</color>", item.m_shared.m_value, item.GetValue());
		}
		if (item.m_shared.m_maxStackSize > 1)
		{
			m_stringBuilder.AppendFormat("\n$item_weight: <color=orange>{0} ({1} $item_total)</color>", item.GetNonStackedWeight().ToString("0.0"), item.GetWeight(stackOverride).ToString("0.0"));
		}
		else
		{
			m_stringBuilder.AppendFormat("\n$item_weight: <color=orange>{0}</color>", item.GetWeight().ToString("0.0"));
		}
		if (item.m_shared.m_maxQuality > 1 && !crafting)
		{
			m_stringBuilder.AppendFormat("\n$item_quality: <color=orange>{0}</color>", qualityLevel);
		}
		if (item.m_shared.m_useDurability)
		{
			if (crafting)
			{
				float maxDurability = item.GetMaxDurability(qualityLevel);
				m_stringBuilder.AppendFormat("\n$item_durability: <color=orange>{0}</color>", maxDurability);
			}
			else
			{
				float maxDurability2 = item.GetMaxDurability(qualityLevel);
				float durability = item.m_durability;
				m_stringBuilder.AppendFormat("\n$item_durability: <color=orange>{0}%</color> <color=yellow>({1}/{2})</color>", (item.GetDurabilityPercentage() * 100f).ToString("0"), durability.ToString("0"), maxDurability2.ToString("0"));
			}
			if (item.m_shared.m_canBeReparied && !crafting)
			{
				Recipe recipe = ObjectDB.instance.GetRecipe(item);
				if (recipe != null)
				{
					int minStationLevel = recipe.m_minStationLevel;
					m_stringBuilder.AppendFormat("\n$item_repairlevel: <color=orange>{0}</color>", minStationLevel.ToString());
				}
			}
		}
		switch (item.m_shared.m_itemType)
		{
		case ItemType.Ammo:
		case ItemType.AmmoNonEquipable:
			m_stringBuilder.Append(item.GetDamage(qualityLevel, worldLevel).GetTooltipString(item.m_shared.m_skillType));
			m_stringBuilder.AppendFormat("\n$item_knockback: <color=orange>{0}</color>", item.m_shared.m_attackForce);
			break;
		case ItemType.OneHandedWeapon:
		case ItemType.Bow:
		case ItemType.TwoHandedWeapon:
		case ItemType.Torch:
		case ItemType.TwoHandedWeaponLeft:
		{
			m_stringBuilder.Append(item.GetDamage(qualityLevel, worldLevel).GetTooltipString(item.m_shared.m_skillType));
			if (item.m_shared.m_attack.m_damageMultiplierByTotalHealthMissing > 0f)
			{
				m_stringBuilder.AppendFormat("\n$item_damagemultipliertotal: <color=orange>{0}%</color>", item.m_shared.m_attack.m_damageMultiplierByTotalHealthMissing * 100f);
			}
			if (item.m_shared.m_attack.m_damageMultiplierPerMissingHP > 0f)
			{
				m_stringBuilder.AppendFormat("\n$item_damagemultiplierhp: <color=orange>{0}%</color>", item.m_shared.m_attack.m_damageMultiplierPerMissingHP * 100f);
			}
			if (item.m_shared.m_attack.m_attackStamina > 0f)
			{
				m_stringBuilder.AppendFormat("\n$item_staminause: <color=orange>{0}</color>", item.m_shared.m_attack.m_attackStamina);
			}
			if (item.m_shared.m_attack.m_attackEitr > 0f)
			{
				m_stringBuilder.AppendFormat("\n$item_eitruse: <color=orange>{0}</color>", item.m_shared.m_attack.m_attackEitr);
			}
			if (item.m_shared.m_attack.m_attackHealth > 0f)
			{
				m_stringBuilder.AppendFormat("\n$item_healthuse: <color=orange>{0}</color>", item.m_shared.m_attack.m_attackHealth);
			}
			if (item.m_shared.m_attack.m_attackHealthReturnHit > 0f)
			{
				m_stringBuilder.AppendFormat("\n$item_healthhitreturn: <color=orange>{0}</color>", item.m_shared.m_attack.m_attackHealthReturnHit);
			}
			if (item.m_shared.m_attack.m_attackHealthPercentage > 0f)
			{
				m_stringBuilder.AppendFormat("\n$item_healthuse: <color=orange>{0}%</color>", item.m_shared.m_attack.m_attackHealthPercentage.ToString("0.0"));
			}
			if (item.m_shared.m_attack.m_drawStaminaDrain > 0f)
			{
				m_stringBuilder.AppendFormat("\n$item_staminahold: <color=orange>{0}</color>/s", item.m_shared.m_attack.m_drawStaminaDrain);
			}
			AddBlockTooltip(item, qualityLevel, m_stringBuilder);
			if (item.m_shared.m_attackForce > 0f)
			{
				m_stringBuilder.AppendFormat("\n$item_knockback: <color=orange>{0}</color>", item.m_shared.m_attackForce);
			}
			if (item.m_shared.m_backstabBonus > 1f)
			{
				m_stringBuilder.AppendFormat("\n$item_backstab: <color=orange>{0}x</color>", item.m_shared.m_backstabBonus);
			}
			if (item.m_shared.m_tamedOnly)
			{
				m_stringBuilder.AppendFormat("\n<color=orange>$item_tamedonly</color>");
			}
			string projectileTooltip = item.GetProjectileTooltip(qualityLevel);
			if (projectileTooltip.Length > 0 && item.m_shared.m_projectileToolTip)
			{
				m_stringBuilder.Append("\n\n");
				m_stringBuilder.Append(projectileTooltip);
			}
			break;
		}
		case ItemType.Helmet:
		case ItemType.Chest:
		case ItemType.Legs:
		case ItemType.Shoulder:
		{
			m_stringBuilder.AppendFormat("\n$item_armor: <color=orange>{0}</color>", item.GetArmor(qualityLevel, worldLevel));
			string damageModifiersTooltipString = SE_Stats.GetDamageModifiersTooltipString(item.m_shared.m_damageModifiers);
			if (damageModifiersTooltipString.Length > 0)
			{
				m_stringBuilder.Append(damageModifiersTooltipString);
			}
			break;
		}
		case ItemType.Shield:
			AddBlockTooltip(item, qualityLevel, m_stringBuilder);
			break;
		case ItemType.Consumable:
			printConsumable(item);
			break;
		}
		float skillLevel = Player.m_localPlayer.GetSkillLevel(item.m_shared.m_skillType);
		string statusEffectTooltip = item.GetStatusEffectTooltip(qualityLevel, skillLevel);
		if (statusEffectTooltip.Length > 0)
		{
			m_stringBuilder.Append("\n\n");
			m_stringBuilder.Append(statusEffectTooltip);
		}
		string chainTooltip = item.GetChainTooltip(qualityLevel, skillLevel);
		if (chainTooltip.Length > 0)
		{
			m_stringBuilder.Append("\n\n");
			m_stringBuilder.Append(chainTooltip);
		}
		if (item.m_shared.m_eitrRegenModifier > 0f && player != null)
		{
			float equipmentEitrRegenModifier = player.GetEquipmentEitrRegenModifier();
			m_stringBuilder.AppendFormat("\n$item_eitrregen_modifier: <color=orange>{0}%</color> ($item_total:<color=yellow>{1}%</color>)", (item.m_shared.m_eitrRegenModifier * 100f).ToString("+0;-0"), (equipmentEitrRegenModifier * 100f).ToString("+0;-0"));
		}
		if (player != null)
		{
			player.AppendEquipmentModifierTooltips(item, m_stringBuilder);
		}
		string setStatusEffectTooltip = item.GetSetStatusEffectTooltip(qualityLevel, skillLevel);
		if (setStatusEffectTooltip.Length > 0)
		{
			m_stringBuilder.AppendFormat("\n\n$item_seteffect (<color=orange>{0}</color> $item_parts):<color=orange>{1}</color>\n{2}", item.m_shared.m_setSize, item.m_shared.m_setStatusEffect.m_name, setStatusEffectTooltip);
		}
		if (item.m_shared.m_fullAdrenalineSE != null)
		{
			m_stringBuilder.AppendFormat("\n$item_fulladrenaline: <color=orange>{0}</color>", item.m_shared.m_fullAdrenalineSE.GetTooltipString());
		}
		if ((bool)item.m_shared.m_appendToolTip && !printConsumable(item.m_shared.m_appendToolTip.m_itemData))
		{
			return m_stringBuilder.ToString() + "\n\n" + GetTooltip(item.m_shared.m_appendToolTip.m_itemData, qualityLevel, crafting, worldLevel);
		}
		return m_stringBuilder.ToString();
		bool printConsumable(ItemData itemData)
		{
			if (itemData.m_shared.m_food > 0f || itemData.m_shared.m_foodStamina > 0f || itemData.m_shared.m_foodEitr > 0f)
			{
				float maxHealth = player.GetMaxHealth();
				float maxStamina = player.GetMaxStamina();
				float maxEitr = player.GetMaxEitr();
				if (itemData.m_shared.m_food > 0f)
				{
					m_stringBuilder.AppendFormat("\n$item_food_health: <color=#ff8080ff>{0}</color>  ($item_current:<color=yellow>{1}</color>)", itemData.m_shared.m_food, maxHealth.ToString("0"));
				}
				if (itemData.m_shared.m_foodStamina > 0f)
				{
					m_stringBuilder.AppendFormat("\n$item_food_stamina: <color=#ffff80ff>{0}</color>  ($item_current:<color=yellow>{1}</color>)", itemData.m_shared.m_foodStamina, maxStamina.ToString("0"));
				}
				if (itemData.m_shared.m_foodEitr > 0f)
				{
					m_stringBuilder.AppendFormat("\n$item_food_eitr: <color=#9090ffff>{0}</color>  ($item_current:<color=yellow>{1}</color>)", itemData.m_shared.m_foodEitr, maxEitr.ToString("0"));
				}
				m_stringBuilder.AppendFormat("\n$item_food_duration: <color=orange>{0}</color>", GetDurationString(itemData.m_shared.m_foodBurnTime));
				if (itemData.m_shared.m_foodRegen > 0f)
				{
					m_stringBuilder.AppendFormat("\n$item_food_regen: <color=orange>{0} hp/tick</color>", itemData.m_shared.m_foodRegen);
				}
				return true;
			}
			return false;
		}
	}

	public static string GetDurationString(float time)
	{
		int num = Mathf.CeilToInt(time);
		int num2 = (int)((float)num / 60f);
		int num3 = Mathf.Max(0, num - num2 * 60);
		if (num2 > 0 && num3 > 0)
		{
			return num2 + "m " + num3 + "s";
		}
		if (num2 > 0)
		{
			return num2 + "m ";
		}
		return num3 + "s";
	}

	private string GetStatusEffectTooltip(int quality, float skillLevel)
	{
		if ((bool)m_shared.m_attackStatusEffect)
		{
			m_shared.m_attackStatusEffect.SetLevel(quality, skillLevel);
			string text = ((m_shared.m_attackStatusEffectChance < 1f) ? $"$item_chancetoapplyse <color=orange>{m_shared.m_attackStatusEffectChance * 100f}%</color>\n" : "");
			return text + "<color=orange>" + m_shared.m_attackStatusEffect.m_name + "</color>\n" + m_shared.m_attackStatusEffect.GetTooltipString();
		}
		if ((bool)m_shared.m_consumeStatusEffect)
		{
			m_shared.m_consumeStatusEffect.SetLevel(quality, skillLevel);
			return "<color=orange>" + m_shared.m_consumeStatusEffect.m_name + "</color>\n" + m_shared.m_consumeStatusEffect.GetTooltipString();
		}
		if ((bool)m_shared.m_equipStatusEffect)
		{
			m_shared.m_equipStatusEffect.SetLevel(quality, skillLevel);
			return "<color=orange>" + m_shared.m_equipStatusEffect.m_name + "</color>\n" + m_shared.m_equipStatusEffect.GetTooltipString();
		}
		return "";
	}

	private string GetChainTooltip(int quality, float skillLevel)
	{
		if (m_shared.m_attack.m_spawnOnHitChance > 0f && m_shared.m_attack.m_spawnOnHit != null)
		{
			return ((m_shared.m_attack.m_spawnOnHitChance < 1f) ? $"$item_chancetoapplyse <color=orange>{m_shared.m_attack.m_spawnOnHitChance * 100f}%</color>\n" : "") + "<color=orange>" + getName(primary: true) + "</color>";
		}
		if (m_shared.m_secondaryAttack.m_spawnOnHitChance > 0f && m_shared.m_secondaryAttack.m_spawnOnHit != null)
		{
			return ((m_shared.m_secondaryAttack.m_spawnOnHitChance < 1f) ? $"$item_chancetoapplyse <color=orange>{m_shared.m_secondaryAttack.m_spawnOnHitChance * 100f}%</color>\n" : "") + "<color=orange>" + getName(primary: false) + "</color>";
		}
		return "";
		string getName(bool primary)
		{
			GameObject gameObject = (primary ? m_shared.m_attack.m_spawnOnHit : m_shared.m_secondaryAttack.m_spawnOnHit);
			Aoe component = gameObject.GetComponent<Aoe>();
			if ((object)component != null)
			{
				return component.m_name;
			}
			ItemDrop component2 = gameObject.GetComponent<ItemDrop>();
			if ((object)component2 != null)
			{
				return component2.m_itemData.m_shared.m_name;
			}
			return gameObject.name;
		}
	}

	private string GetEquipStatusEffectTooltip(int quality, float skillLevel)
	{
		if ((bool)m_shared.m_equipStatusEffect)
		{
			StatusEffect equipStatusEffect = m_shared.m_equipStatusEffect;
			m_shared.m_equipStatusEffect.SetLevel(quality, skillLevel);
			if (equipStatusEffect != null)
			{
				return equipStatusEffect.GetTooltipString();
			}
		}
		return "";
	}

	private string GetSetStatusEffectTooltip(int quality, float skillLevel)
	{
		if ((bool)m_shared.m_setStatusEffect)
		{
			StatusEffect setStatusEffect = m_shared.m_setStatusEffect;
			m_shared.m_setStatusEffect.SetLevel(quality, skillLevel);
			if (setStatusEffect != null)
			{
				return setStatusEffect.GetTooltipString();
			}
		}
		return "";
	}

	private string GetProjectileTooltip(int itemQuality)
	{
		string text = "";
		if ((bool)m_shared.m_attack.m_attackProjectile)
		{
			IProjectile component = m_shared.m_attack.m_attackProjectile.GetComponent<IProjectile>();
			if (component != null)
			{
				text += component.GetTooltipString(itemQuality);
			}
		}
		if ((bool)m_shared.m_spawnOnHit)
		{
			IProjectile component2 = m_shared.m_spawnOnHit.GetComponent<IProjectile>();
			if (component2 != null)
			{
				text += component2.GetTooltipString(itemQuality);
			}
		}
		return text;
	}

	public override string ToString()
	{
		return string.Format("{0}: stack: {1}, quality: {2}, Shared: {3}", "ItemData", m_stack, m_quality, m_shared);
	}
}
