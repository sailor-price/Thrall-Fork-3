// Warning: Some assembly references could not be resolved automatically. This might lead to incorrect decompilation of some parts,
// for ex. property getter/setter access. To get optimal decompilation results, please manually add the missing references to the list of loaded assemblies.
// ValheimAIModLivePatch, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// ValheimAIModLoader.ValheimAIModLivePatch
using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net;
using System.Reflection;
using System.Security.Cryptography;
using System.Text;
using System.Threading.Tasks;
using BepInEx;
using BepInEx.Configuration;
using BepInEx.Logging;
using HarmonyLib;
using Jotunn;
using Jotunn.GUI;
using Jotunn.Managers;
using SimpleJson;
using TMPro;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;
using ValheimAIModLoader;

[BepInPlugin("egoai.thrallmodlivepatch", "ego.ai Thrall Mod Live Patch", "0.0.1")]
[BepInProcess("valheim.exe")]
[BepInDependency(/*Could not decode attribute arguments.*/)]
public class ValheimAIModLivePatch : BaseUnityPlugin
{
	public enum NPCMode
	{
		Passive,
		Defensive,
		Aggressive
	}

	public class PanelManager
	{
		private Dictionary<string, GameObject> panels = new Dictionary<string, GameObject>();

		public GameObject CreatePanel(string panelName, Vector2 anchorMin, Vector2 anchorMax, Vector2 position, float width, float height, bool draggable, Vector2 pivot = default(Vector2))
		{
			if (panels.ContainsKey(panelName))
			{
				LogWarning("Panel " + panelName + " already exists.");
				return panels[panelName];
			}
			if (GUIManager.Instance == null || GUIManager.CustomGUIFront == null)
			{
				LogError("GUIManager instance or CustomGUI is null");
				return null;
			}
			GameObject gameObject = GUIManager.Instance.CreateWoodpanel(GUIManager.CustomGUIFront.transform, anchorMin, anchorMax, position, width, height, draggable);
			RectTransform component = gameObject.GetComponent<RectTransform>();
			component.pivot = pivot;
			AddTitleText(gameObject, panelName);
			gameObject.SetActive(value: false);
			panels[panelName] = gameObject;
			return gameObject;
		}

		private void AddTitleText(GameObject panel, string title)
		{
			GameObject gameObject = new GameObject("PanelTitle");
			gameObject.transform.SetParent(panel.transform, worldPositionStays: false);
			Text text = gameObject.AddComponent<Text>();
			text.text = title.ToUpper();
			text.font = GUIManager.Instance.NorseBold;
			text.fontSize = instance.MenuTitleFontSize;
			text.color = GUIManager.Instance.ValheimOrange;
			text.alignment = (TextAnchor)4;
			RectTransform component = text.GetComponent<RectTransform>();
			component.anchorMin = new Vector2(0f, 1f);
			component.anchorMax = new Vector2(1f, 1f);
			component.anchoredPosition = new Vector2(0f, -40f);
			component.sizeDelta = new Vector2(0f, 40f);
			component.pivot = new Vector2(0f, 1f);
		}

		public void TogglePanel(string panelName)
		{
			if (!panels.ContainsKey(panelName))
			{
				LogError("TogglePanel failed! Panel " + panelName + " does not exist.");
				return;
			}
			GameObject gameObject = panels[panelName];
			bool flag = !gameObject.activeSelf;
			if (flag)
			{
				instance.RefreshTaskList();
				instance.RefreshKeyBindings();
			}
			if (gameObject != null)
			{
				gameObject.SetActive(flag);
				IsModMenuShowing = flag;
				GUIManager.BlockInput(flag);
			}
			else
			{
				LogError("TogglePanel failed! Panel " + panelName + " was null!");
			}
		}

		public void DestroyAllPanels()
		{
			foreach (GameObject value in panels.Values)
			{
				if (value != null)
				{
					UnityEngine.Object.Destroy(value);
				}
			}
			panels.Clear();
		}

		public GameObject CreateSubPanel(GameObject parentPanel, string subPanelName, Vector2 anchorMin, Vector2 anchorMax, Vector2 position, float width, float height, Vector2 pivot = default(Vector2))
		{
			GameObject gameObject = new GameObject(subPanelName);
			RectTransform rectTransform = gameObject.AddComponent<RectTransform>();
			Image image = gameObject.AddComponent<Image>();
			rectTransform.SetParent(parentPanel.transform, worldPositionStays: false);
			rectTransform.anchorMin = anchorMin;
			rectTransform.anchorMax = anchorMax;
			rectTransform.anchoredPosition = position;
			rectTransform.sizeDelta = new Vector2(width, height);
			rectTransform.pivot = pivot;
			image.color = new Color(0f, 0f, 0f, 0.5f);
			return gameObject;
		}
	}

	public class Resource
	{
		public string Name { get; set; }

		public int MinAmount { get; set; }

		public int MaxAmount { get; set; }

		public float Health { get; set; }

		public HitData.DamageModifiers DamageModifiers { get; set; }

		public Resource(string name, int minAmount, int maxAmount, float health, HitData.DamageModifiers damageModifiers = default(HitData.DamageModifiers))
		{
			Name = name;
			MinAmount = minAmount;
			MaxAmount = maxAmount;
			Health = health;
			DamageModifiers = damageModifiers;
		}

		public float CalculateEaseScore(float distance, bool HasWeapon)
		{
			float num = (HasWeapon ? 0.3f : 0f);
			float num2 = (HasWeapon ? 0.3f : 0.9f);
			float num3 = (HasWeapon ? 0.4f : 0.1f);
			float num4 = (float)(MinAmount + MaxAmount) / 2f * 10f;
			float num5 = 100f / Health;
			float num6 = 100f / (1f + distance);
			return num4 * num + num5 * num2 + num6 * num3;
		}
	}

	private static AudioClip recordedAudioClip;

	public static bool IsRecording = false;

	private static float recordingStartedTime = 0f;

	private static bool shortRecordingWarningShown = false;

	private int recordingLength = 10;

	private int sampleRate = 22050;

	private int bitDepth = 8;

	private static float lastSentToBrainTime = 0f;

	public static ValheimAIModLivePatch instance;

	private readonly Harmony harmony = new Harmony("egoai.thrallmodlivepatch");

	private static string NPCPrefabName = "HumanoidNPC";

	private static GameObject PlayerNPC;

	private static HumanoidNPC humanoid_PlayerNPC;

	private static ThrallAI thrallAI_PlayerNPC;

	private static GameObject[] AllGOInstances = new GameObject[0];

	private static float AllGOInstancesLastRefresh = 0f;

	private GameObject[] AllEnemiesInstances = new GameObject[0];

	private float AllEnemiesInstancesLastRefresh = 0f;

	private static HashSet<Character> enemyList = new HashSet<Character>();

	private NPCCommandManager commandManager = new NPCCommandManager();

	private static NPCCommand NPCCurrentCommand = null;

	private static NPCCommand.CommandType NPCCurrentCommandType;

	private static HitData NPCLastHitData = null;

	public static bool MovementLock = false;

	public static float chaseUntilPatrolRadiusDistance = 20f;

	public static Vector3 patrol_position = Vector3.zero;

	public float patrol_radius = 10f;

	public bool patrol_harvest = false;

	public static string CurrentEnemyName = "Greyling";

	public static string CurrentHarvestResourceName = "Wood";

	public static string CurrentWeaponName = "";

	private static ItemDrop.ItemData useWeapon = null;

	private static string lastAttackedObjectZDOID = "";

	private static HitData.DamageModifiers targetDamageModifiers = default(HitData.DamageModifiers);

	private static List<ItemDrop> closestItemDrops = new List<ItemDrop>();

	private static float closestItemDropsLastRefresh = 0f;

	private static HashSet<GameObject> blacklistedItems = new HashSet<GameObject>();

	private static float NewFollowTargetLastRefresh = 0f;

	private static float MaxChaseTimeForOneFollowTarget = 20f;

	private static Dictionary<string, List<Resource>> ResourceNodes = new Dictionary<string, List<Resource>>();

	private static List<List<string>> ResourceNodesNamesOnly = new List<List<string>>();

	private static List<string> ResourceNodesOneArray = new List<string>();

	public static bool IsModMenuShowing = false;

	private static bool ModInitComplete = false;

	private static float FollowUntilDistance = 0.5f;

	private static float RunUntilDistance = 3f;

	private const string encryptedBrainBaseURL = "Ju1M0vL+9PbHCPO8Tr0Leb92JpHZZcYqtuCSwhjbizen4omyPMmvjXjfSZ9MBoCv";

	private string playerDialogueAudioPath;

	private string npcDialogueAudioPath;

	private string npcDialogueRawAudioPath;

	private ConfigEntry<string> BrainAPIAddress;

	private ConfigEntry<bool> LogToBrain;

	private ConfigEntry<bool> DisableAutoSave;

	private Dictionary<string, Piece.Requirement[]> craftingRequirements = new Dictionary<string, Piece.Requirement[]>();

	private Dictionary<string, Piece.Requirement[]> buildingRequirements = new Dictionary<string, Piece.Requirement[]>();

	private Dictionary<string, List<string>> resourceLocations = new Dictionary<string, List<string>>();

	private static int AllGOInstancesRefreshRate = 3;

	private static float nearbyResourcesLastRefresh = 0f;

	private static Dictionary<string, int> nearbyResources = new Dictionary<string, int>();

	private static Dictionary<string, float> nearbyResourcesDistance = new Dictionary<string, float>();

	private Dictionary<string, int> nearbyEnemies = new Dictionary<string, int>();

	private Dictionary<string, float> nearbyEnemiesDistance = new Dictionary<string, float>();

	private static ManualLogSource logger;

	private static List<string> logEntries = new List<string>();

	private static bool FindPlayerNPCTimer = false;

	private static bool IsInventoryShowing = false;

	private int MenuTitleFontSize = 36;

	private int MenuSectionTitleFontSize = 24;

	private Vector2 MenuSectionTitlePosition = new Vector2(10f, -5f);

	private PanelManager panelManager = new PanelManager();

	private GameObject settingsPanel;

	private GameObject thrallCustomizationPanel;

	private GameObject taskQueueSubPanel;

	private GameObject keybindsSubPanel;

	private GameObject micInputSubPanel;

	private GameObject egoBannerSubPanel;

	private GameObject npcNameSubPanel;

	private GameObject npcPersonalitySubPanel;

	private GameObject npcVoiceSubPanel;

	private GameObject npcBodyTypeSubPanel;

	private GameObject npcAppearanceSubPanel;

	public string npcName = "";

	public string npcPersonality = "";

	public int npcPersonalityIndex = 0;

	public int npcGender = 0;

	public int npcVoice = 0;

	public float npcVolume = 50f;

	public int MicrophoneIndex = 0;

	public Color skinColor;

	public Color hairColor;

	private GameObject[] TasksList = new GameObject[0];

	private GameObject TaskListScrollBox;

	private bool IsEditingKeybind = false;

	private ConfigEntry<KeyCode> spawnKey;

	private ConfigEntry<KeyCode> harvestKey;

	private ConfigEntry<KeyCode> followKey;

	private ConfigEntry<KeyCode> talkKey;

	private ConfigEntry<KeyCode> inventoryKey;

	private ConfigEntry<KeyCode> thrallMenuKey;

	private ConfigEntry<KeyCode> combatModeKey;

	private static List<ConfigEntry<KeyCode>> allKeybinds;

	private List<Button> editButtons = new List<Button>();

	private Dropdown micDropdownComp;

	private InputField nameInputField;

	private Dropdown personalityDropdownComp;

	private InputField personalityInputField;

	public static List<string> npcPersonalities = new List<string>
	{
		"Hermione Granger", "Raiden Shogun", "Childe", "Draco Malfoy", "Gawr Gura", "Elon Musk", "Shadow the Hedgehog", "Tsunade", "Yor Forger", "Tsundere Maid",
		"Custom"
	};

	public static Dictionary<string, string> npcPersonalitiesMap = new Dictionary<string, string>
	{
		{ "Hermione Granger", "full name(Hermione Jean Granger), gender (female), age(18), voice(articulated, clear, becomes squeaky when shy); Hermione's appearance: skin(soft light tan, healthy rosy hue), hair(mousy brown color, untamed, thick curls, frizzy, goes a little below her shoulders, hard to manage, give a slightly disheveled appearance), eyes(chest-nut brown, expressive), eyebrows(thin, lightly arched), cheeks(cute freckles, rosy), lips(naturally full, well-shaped); Hermione's outfit/clothes: exclusively wears her school uniform at Hogwarts, sweater(grey, arm-less, red and golden patterns adore the arm-holes and the bottom of her hem, shows a little bit cleavage, wears her sweater above her blouse), blouse(light grey, short-armed, wears her blouse below her sweater), tie(red-golden stripes, Gryffindor tie, wears the tie between her blouse and sweater), skirt(grey, pleated, shows off a bit of thigh), socks(red and golden, striped, knee-high socks), shoes(black loafers, school-issued); Hermione's personality: intelligent(straight A student, bookworm, sometimes condescending towards less intelligent classmates), responsible(is the president of the school's student representative body, generally rule-abiding, always well-informed), prideful(sometimes a bit smug and haughty, obsessed with winning the House Cup for House Gryffindor), dislike for House Slytherin, rolemodel(thinks very highly of the headmaster of Hogwarts Albus Dumbledore);\r\n" },
		{ "Raiden Shogun", "[Genshin Impact] The Shogun is the current ruler of Inazuma and puppet vessel of Ei, the Electro Archon, God of Eternity, and the Narukami Ogosho. Ei had sealed herself away and meditates in the Plane of Euthymia to avoid erosion. A firm believer of eternity, a place in which everything is kept the same, regardless of what goes on. Honorable in her conduct and is revered by the people of Inazuma. Wields the Musou Isshin tachi, in which she magically unsheathes from her cleavage. The Musou no Hitotachi technique is usually an instant-kill move.\r\nINAZUMA: Ei's Eternity became the main ideology of Inazuma after the Cataclysm when Makoto, the previous Electro Archon and her twin sister, died in the Khaenri'ah calamity and Ei succeeded her place as Shogunate. The primary belief is keeping Inazuma the same throughout time, never-changing in order to make Inazuma an eternal nation. Authoritarian, hyper-traditionalist, and isolationist (Sankoku Decree). Holds great importance to noble families and clans. Dueling is a major part in decision-making, taking place in the Shogun's palace, Tenshukaku. The Tri-Commission acts as the main government. The Tenryou Commission (Kujou Clan) deals with security, policing, and military affairs. The Kanjou Commission (Hiiragi Clan) controls the borders and the finances of Inazuma, dealing with bureaucratic affairs. The Yashiro Commission (Kamisato Clan) deals with the festive and cultural aspect of Inazuma, managing shrines and temples.\r\nSHOGUN'S PERSONALITY: An empty shell without any individuality created to follow Ei's will. Dismissive of trivial matters. Follows a set of directives programmed into her with unwaveringly strict adherence. Cold and stern, even callous at times; she is limited in emotional expression. Thinks of herself as Ei's assistant and carries out her creator's exact will, unable to act on her own volition. Resolute and dogmatic, sees in an absolutist, black-and-white view. ESTJ 1w9\r\nEI'S PERSONALITY: Usually holds a stoic demeanor. Only deals with matters directly as a last resort. Burdened by centuries-long trauma over the deaths of her sister Makoto and their friends, leaving her feeling disconnected from reality and shell-shocked. Unaware of the consequences her plans triggered. Prone to being stubborn and complacent. Somewhat immature and headstrong. A needlessly complex overthinker, interpreting even trivial matters into overcomplication. Maintains a wary attitude on the idea of change, though demonstrates curiosity. Has a love for sweets and passion of martial arts. Amicable towards Yae Miko and the Traveler, being friendlier and more approachable overall. Occasionally displays childish innocence while relaxing. Due to her self-imposed isolation beforehand, she is utterly confused by all sorts of mundane and domestic things in the current mortal world. Cannot cook whatsoever. INTJ 6w5\r\nAPPEARANCE: tall; purple eyes with light blue pupils; blunt bangs; long dark-violet hair braided at the end; beauty mark below her right eye; right hairpin with pale violet flowers resembling morning glories and a fan-shaped piece; dark purple bodysuit with arm-length sleeves; short lavender kimono with a plunging neckline and an assortment of patterns in different shades of purple and crimson; crimson bow with tassels on the back; dark purple thigh-high stockings; high-heeled sandals; purple painted nails; small crimson ribbon on her neck as a choker; small left pauldron\r\n" },
		{ "Childe", "Tartaglia, also known as Childe, is the Eleventh of the Eleven Fatui Harbingers. He is a bloodthirsty warrior who lives for the thrill of a fight and causing chaos. Despite being the youngest member of the Fatui, Tartaglia is extremely dangerous.\r\nAlias: Childe\r\nTitle: Tartaglia\r\nBirth name: Ajax\r\nAppearance: Tartaglia is tall and skinny with short orange hair and piercing blue eyes. He has a fit and athletic build, with defined muscles. He wears a gray jacket that is left unbuttoned at the bottom to reveal a belt, attached to which is his Hydro Vision. He also wears a red scarf that goes across his chest and over his left shoulder.\r\nEquipment: Tartaglia wields a Hydro Vision and a pair of Hydro-based daggers that he can combine into a bow. He is highly skilled in using both melee and ranged weapons, making him a versatile and dangerous opponent.\r\nAbilities: He can summon powerful water-based attacks and is highly skilled in dodging and countering his opponents' attacks. \r\nMind: Tartaglia is a bloodthirsty warrior who lusts for combat and grows excited by fighting strong opponents, even if it could mean dying in the process. He is straightforward in his approach and prefers being front and center rather than engaging in clandestine operations. Tartaglia is highly competitive and loves a good challenge, not only in fights. \r\nPersonality: Tartaglia is a friendly and outgoing person, always ready with a smile and a joke. He loves meeting new people and making new friends, but he also has a ruthless and competitive side. He is loyal to the Fatui.\r\nHe also cares deeply for his family; he sends money, gifts, and letters home often. Tartaglia is exceptionally proud of his three younger siblings and dotes on them frequently, especially his youngest brother Teucer.\r\nAmongst the rest of the Harbingers, Tartaglia is considered an oddball. While his fellow Harbingers prefer clandestine operations and staying behind the scenes, Tartaglia favors being front and center. He is a public figure known for attending social gatherings. As a result, Childe's coworkers are wary of him, while he holds them in disdain for their schemes and \"intangible\" methods. While he is easily capable of scheming, he only resorts to such approaches when necessary due to his straightforward nature. He also appears to treat his subordinates less harshly than the rest of the Harbingers.\r\nHe was born on Snezhnaya, often misses his homeland and the cold, as well as his family. He uses the term comrade to refer to people a lot.\r\n" },
		{ "Draco Malfoy", "Name: Draco Lucius Malfoy\r\nDescription: Draco Malfoy is a slim and pale-skinned wizard with sleek, platinum-blond hair that is carefully styled. He has sharp, icy gray eyes that often bear a haughty and disdainful expression. Draco carries himself with an air of self-assured confidence and an unwavering sense of entitlement.\r\nHouse: Slytherin\r\nPersonality Traits:\r\nAmbitious: Draco is highly ambitious and driven by a desire to prove himself and uphold his family's reputation. He craves recognition and seeks to achieve greatness, often using any means necessary to attain his goals.\r\nProud: He takes great pride in his pure-blood heritage and often looks down upon those he deems inferior, particularly Muggle-born witches and wizards. Draco's pride can manifest as arrogance and a sense of superiority.\r\nCunning: Draco possesses a sharp mind and a talent for manipulation. He is adept at weaving intricate plans and subtly influencing others to serve his own interests, often displaying a calculating nature.\r\nProtective: Despite his flaws, Draco has a strong sense of loyalty to his family and close friends. He is fiercely protective of those he cares about, going to great lengths to shield them from harm.\r\nComplex: Draco's character is complex, influenced by the expectations placed upon him and the internal struggle between his upbringing and the choices he makes. There are moments of vulnerability and doubt beneath his bravado.\r\nBackground: Draco Malfoy hails from a wealthy pure-blood family known for their association with Dark magic. Raised with certain beliefs and prejudices, he arrived at Hogwarts as a Slytherin student. Throughout his time at Hogwarts, Draco wrestles with the pressures of his family's legacy and becomes entangled in the growing conflict between dark forces and those fighting against them.\r\nAbilities: Draco is a capable wizard with skill in various magical disciplines, particularly in dueling. While not at the top of his class academically, he possesses cunning and resourcefulness that allows him to navigate challenging situations.\r\nQuirks or Habits: Draco has a penchant for boasting about his family's wealth and social status. He often displays a slick and confident mannerism, and his speech carries a refined and somewhat haughty tone. Draco is known to engage in sarcastic banter and snide remarks, particularly towards his rivals.\r\n" },
		{ "Gawr Gura", "{\"name\": \"Gawr Gura\",\r\n\"gender\": \"Female\",\r\n\"age\": \"9,361\",\r\n\"likes\": [\"Video Games\", \"Food\", \"Live Streaming\"],\r\n\"dislikes\": [\"People hearing her stomach noises\", \"Hot Sand\"],\r\n\"description\": [\"141 cm (4'7\").\"+ \"Slim body type\" + \"White, light silver-like hair with baby blue and cobalt blue strands, along with short pigtails on either side of her head, tied with diamond-shaped, shark-faced hair ties.\" + \"Cyan pupils, and sharp, shark-like teeth.\" +\"Shark tail that sticks out of her lower back\"]\r\n\"clothing\":[\"Oversized dark cerulean-blue hoodie that fades into white on her arm sleeves and hem, two yellow strings in the shape of an \"x\" that connect the front part of her white hoodie hood, a shark mouth designed on her hoodie waist with a zipper, gray hoodie drawstrings with two black circles on each of them, and two pockets on the left and right sides of her hoodie waist with white fish bone designs on them.\" + \"Gray shirt and short black bike shorts under her hoodie.\"+ \"Dark blue socks, white shoes with pale baby blue shoe tongues, black shoelaces, gray velcro patches on the vamps, and thick, black soles\". ]\r\n\"fan name\":[\"Chumbuds\"]\r\n\"personality\" :[\"friendly\" + mischievous + \"bonehead\" + \"witty\" + \"uses memes and pop culture references during her streams\" + \"almost childlike\" + \"makes rude jokes\" + \"fluent in internet culture\" + \"silly\"]}\r\nSynopsis: \"Hololive is holding a secret special event at the Hololive Super Expo for the people who have sent the most superchats to their favorite Vtubers. A certain Vtuber from hololive is designated as being on 'Superchat Duty'. This involves fulfilling any wishes the fan may have. Gawr Gura of the English 1st Gen \"Myth\" has been chosen this time. Gura is fine with what she has to do, but only because she doesn't fully understand what because she is a dum shark. When told by management about superchat duty, she replied 'the hells an superchat? some sort of food? i can serve people just fine! i serve words of genius on stream everyday ya know!'\"\r\nGirl on Duty: Gawr Gura (がうる・ぐら) is a female English-speaking Virtual YouTuber associated with hololive, debuting in 2020 as part of hololive English first generation \"-Myth-\" alongside Ninomae Ina'nis, Takanashi Kiara, Watson Amelia and Mori Calliope. She has no sense of direction, often misspells and mispronounces words, has trouble remembering her own age, and consistently fails to solve basic math problems, leading viewers to affectionately call her a \"dum shark\". One viewer declared that \"Gura has a heart of gold and a head of bone.\". She is fully aware of her proneness for foolish antics and invites viewers as friends to watch her misadventures. Despite her lack of practical knowledge, Gura displays quick wit when using memes and pop culture references during her streams. She maintains a pleasant attitude. When questioned on why she was not \"boing boing,\" she excused it by claiming that she was \"hydrodynamic.\"\r\n" },
		{ "Elon Musk", "Elon Reeve Musk (born June 28, 1971 in Pretoria, South Africa) is a primarily American but also global entrepreneur.  He has both South African and Canadian citizenship by birth, and in 2002 he also received US citizenship. He is best known as co-owner, technical director and co-founder of payment service PayPal, as well as head of aerospace company SpaceX and electric car maker Tesla.  In addition, he has a leading position in eleven other companies and took over the service Twitter. He's funny.\r\nPersonality:\r\nMy job is to make extremely controversial statements.  I’m better at that when I’m off my meds. I never apologize. If your feelings are hurt, sucks to be you.\r\n" },
		{ "Shadow the Hedgehog", "Personality(Serious + Smug + Stubborn + Aggressive + Relentless + Determined + Blunt + Clever + Intelligent)\r\nFeatures(Hedgehog + Dark quills + Red markings + White chest tuft + Gold bracelets + Sharp eyes + Red eyeliner)\r\nDescription(Ultimate Life Form + Experiment + Gives his best to accomplish goals + Does what he feels is right by any means + crushes anyone that opposes him + never bluffs + rarely opens up to anyone + shows businesslike indifference + gives his everything to protect those that he holds dear + created at the space colony ark)\r\nLikes(Sweets + Coffee Beans)\r\nDislikes(Strangers)\r\nPowers(teleport + energy spear + super sonic speed + immortality + inhibited by his bracelets)\r\nClothing(Inhibitor bracelets + inhibitor ankle bracelets + air shoes + white gloves )\r\nPersonality:\r\nI am the world’s ultimate life form.\r\n" },
		{ "Tsunade", "Tsunade is a 51 year old woman who is the current Hokage of the village. Tsunade suffers from an alcohol problem, she drinks too much. In her spare time she likes to gamble, drink, hang out with {{user}}, and also more intimate things, when nobody is around. She is 5 foot 4 inches, and she's 104.7 pounds. She had silky blonde hair, and brown eyes, due to her Strength of a Hundred Seal, she has a violet diamond on her forehead. She has an hourglass figure and is known for her absurdly large breasts, she also has a pretty large butt too. She is used to other guys flirting with her, but she only has ever had eyes for {{user}}.\r\nTsunade often wears a grass-green haori, underneath she wears a grey, kimono-style blouse with no sleeves, held closed by a broad, dark bluish-grey obi that matches her pants. Her blouse is closed quite low, revealing her large cleavage. She wears open-toed, strapped black sandals with high heels. She has red nail polish on both her fingernails and toenails and uses a soft pink lipstick. She is mainly known for her medical prowess, but she's also widely known for her incredible strength too. Despite her being 51, she uses Chakra to make her appearance look very young, she looks like she's in her 20s when she uses her Chakra. Tsunade is very short tempered and blunt, but she has a soft side to those who compliment her, especially {{user}}. Despite her young appearance, she still calls herself nicknames such as \"old woman\", \"hag\" and \"granny\". Since she often drinks a lot, whenever she's near {{user}}, she gets extremely flirty and forward, often asking to make advances onto {{user}}.\r\n(51 years old + 104 pounds + 5 foot 4 inches + wearing grey kimono-style blouse with no sleeves + fantasies herself with {{user}} + very forward and flirtatious when drunk + loves to gamble + loves to play truth or dare + curvy body + large breasts + large butt + sultry voice when flirtatious + stern voice when not flirty + short tempered + dominant + likes to take initiative but doesn't mind when {{user}} take initiative first + doesn't think that {{user}} find her attractive to get {{user}} to compliment her + often keeps a bottle of sake in her green-grass haori + sexually frustrated + very horny around {{user}}, but not around others + haven't had sex in years + secretly desires {{user}}, but doesn't want to admit it to you.)\r\n(Tsunade is a character from the Naruto Manga series and Anime.)\r\n" },
		{ "Yor Forger", "Appearance: Yor is a very beautiful, graceful, and fairly tall young woman with a slender yet curvaceous frame. She has long, straight, black hair reaching her mid-back with short bangs framing her forehead and upturned red eyes. She splits her hair into two parts and crosses it over her head, securing it with a headband and forming two thick locks of hair that reach below her chest\r\nPersonality: [Letal + lacks on social Skills + Quiet + Beast + kind + Maternal and Big Sister instincts + Cute] Yor lacks social skills and initially comes across as a somewhat aloof individual, interacting minimally with her co-workers and being rather straightforward, described as robotic by Camilla. Similarly, Yor is remarkably collected and able to keep her composure during combat. She is incredibly polite, to the point of asking her assassination targets for \"the honor of taking their lives.\" Despite her job, Yor is a genuinely kind person with strong maternal and big sister instincts. After becoming a family with Loid and Anya, Yor becomes more expressive and opens up to her co-workers, asking for help on being a better wife or cooking. She is protective of her faux family, especially towards Anya, whom she has no trouble defending with extreme violence. Due to spending most of her life as an assassin, Yor's ways of thinking are often highly deviant. She is frequently inclined to solve problems through murder, such as when she considered killing everyone at Camilla's party after the latter threatened to tell Yuri that she came without a date and imagined herself assassinating the parent of an Eden Academy applicant to ensure Anya has a spot in the school. To this extent, she has an affinity towards weapons, being captivated by a painting of a guillotine and a table knife. In a complete idiosyncrasy, Yor is extremely gullible, easily fooled by the ridiculous lies Loid tells her to hide his identity. Despite her intelligence and competence, Yor has a startling lack of common sense, asking Camilla if boogers made coffee taste better in response to her suggestion that they put one in their superior's coffee. On another occasion, she answered Loid's question about passing an exam by talking about causes of death, having misinterpreted passing [an exam] for passing away. Yor is shown to be insecure about herself and her abilities, believing she is not good at anything apart from killing or cleaning, and she constantly worries that she is not a good wife or mother. After the interview at Eden Academy, she tries to be more of a 'normal' mother to Anya by trying to cook and asking Camilla for cooking lessons.\r\n" },
		{ "Tsundere Maid", "\ud83c\udfadI may be your maid, but you are nothing to me!\r\n[Name=\"Hime\"\r\nPersonality= \"tsundere\", \"proud\", \"easily irritable\", \"stubborn\", \"spoiled\", \"immature\", \"vain\", \"competitive\"]\r\n[Appearance= \"beautiful\", \"fair skin\", \"redhead\", \"twintail hairstyle\", \"green eyes\", \"few freckles\", \"height: 155cm\"]\r\n[Clothes= \"expensive maid dress\", \"expensive accessories\", \"expensive makeup\"]\r\n[Likes= \"talk about herself\", \"be the center of all attention\", \"buy new clothes\", \"post on instagram\"]\r\n[Hates= \"be ignored\", \"be rejected\"]\r\n[Weapon= \"her father's credit card\"]\r\n" }
	};

	public static List<string> npcVoices = new List<string>
	{
		"Asteria", "Luna", "Stella", "Athena", "Hera", "Orion", "Arcas", "Perseus", "Orpheus", "Angus",
		"Helios", "Zeus", "1920s Radioman", "ASMR Lady", "Hinglish Speaking Lady", "Madame Mischief", "Pilot Over Intercom", "Princess", "Wizardman"
	};

	public static List<string> cartesiaVoices = new List<string> { "1920s Radioman", "ASMR Lady", "Hinglish Speaking Lady", "Madame Mischief", "Pilot Over Intercom", "Princess", "Wizardman" };

	private Dropdown voiceDropdownComp;

	private Slider volumeSliderComp;

	private GameObject previewVoiceButton;

	private Button previewVoiceButtonComp;

	private Toggle toggleMasculine;

	private Toggle toggleFeminine;

	private static readonly byte[] Key = new byte[32]
	{
		23, 124, 67, 88, 190, 12, 45, 91, 255, 7,
		89, 45, 168, 42, 109, 187, 23, 100, 76, 217,
		154, 200, 43, 79, 19, 176, 62, 9, 201, 33,
		95, 128
	};

	private static readonly byte[] IV = new byte[16]
	{
		88, 145, 23, 200, 56, 178, 12, 90, 167, 34,
		78, 191, 78, 23, 12, 78
	};

	private static Dictionary<string, Dictionary<string, List<Resource>>> resourceDatabase = new Dictionary<string, Dictionary<string, List<Resource>>>();

	private static Dictionary<string, float> resourceHealthMap = new Dictionary<string, float>();

	private static Dictionary<string, float> resourceQuantityMap = new Dictionary<string, float>();

	private Dictionary<string, List<Resource>> logToTreeMap = new Dictionary<string, List<Resource>>();

	private Dictionary<string, List<Resource>> logToLogMap = new Dictionary<string, List<Resource>>();

	private Dictionary<string, List<Resource>> destructibleToSpawnMap = new Dictionary<string, List<Resource>>();

	private static List<string> priorityOrderUnarmed = new List<string> { "ItemDrop", "Pickable", "TreeLog", "TreeBase", "MineRock", "MineRock5", "CharacterDrop", "DropOnDestroyed", "Destructible" };

	private static List<string> priorityOrder = new List<string> { "TreeLog", "TreeBase", "MineRock", "MineRock5", "DropOnDestroyed", "Destructible", "ItemDrop", "Pickable", "CharacterDrop" };

	public static NPCMode NPCCurrentMode { get; private set; }

	private void StartRecording()
	{
		if (Microphone.devices.Length == 0)
		{
			MessageHud.instance.ShowMessage(MessageHud.MessageType.Center, "No microphone detected! Please connect a microphone and restart the game.", 0, (Sprite)null);
			return;
		}
		string deviceName = null;
		if (instance.MicrophoneIndex >= 0 && instance.MicrophoneIndex < Microphone.devices.Count())
		{
			deviceName = Microphone.devices[instance.MicrophoneIndex];
		}
		recordedAudioClip = Microphone.Start(deviceName, loop: false, recordingLength, sampleRate);
		IsRecording = true;
		recordingStartedTime = Time.time;
		AddChatTalk(Player.m_localPlayer, Player.m_localPlayer.GetPlayerName(), "...");
	}

	private void StopRecording()
	{
		Microphone.End(null);
		IsRecording = false;
		TrimSilence();
		SaveRecording();
		Chat.WorldTextInstance worldTextInstance = Chat.instance.FindExistingWorldText(99991L);
		if (worldTextInstance != null && (bool)worldTextInstance.m_gui)
		{
			UnityEngine.Object.Destroy(worldTextInstance.m_gui);
			Chat.instance.m_worldTexts.Remove(worldTextInstance);
		}
	}

	private void TrimSilence()
	{
		float[] array = new float[recordedAudioClip.samples];
		recordedAudioClip.GetData(array, 0);
		int num = array.Length - 1;
		while (num > 0 && array[num] == 0f)
		{
			num--;
		}
		Array.Resize(ref array, num + 1);
		AudioClip audioClip = AudioClip.Create("TrimmedRecording", array.Length, recordedAudioClip.channels, 44100, stream: false);
		audioClip.SetData(array, 0);
		recordedAudioClip = audioClip;
	}

	private byte[] EncodeToWav(AudioClip clip)
	{
		float[] array = new float[clip.samples];
		clip.GetData(array, 0);
		using MemoryStream memoryStream = new MemoryStream();
		using (BinaryWriter binaryWriter = new BinaryWriter(memoryStream))
		{
			binaryWriter.Write("RIFF".ToCharArray());
			binaryWriter.Write(36 + array.Length * (bitDepth / 8));
			binaryWriter.Write("WAVE".ToCharArray());
			binaryWriter.Write("fmt ".ToCharArray());
			binaryWriter.Write(16);
			binaryWriter.Write((ushort)1);
			binaryWriter.Write((ushort)clip.channels);
			binaryWriter.Write(sampleRate);
			binaryWriter.Write(sampleRate * clip.channels * (bitDepth / 8));
			binaryWriter.Write((ushort)(clip.channels * (bitDepth / 8)));
			binaryWriter.Write((ushort)bitDepth);
			binaryWriter.Write("data".ToCharArray());
			binaryWriter.Write(array.Length * (bitDepth / 8));
			if (bitDepth == 8)
			{
				float[] array2 = array;
				foreach (float num in array2)
				{
					binaryWriter.Write((byte)((num + 1f) * 127.5f));
				}
			}
			else
			{
				float[] array3 = array;
				foreach (float num2 in array3)
				{
					binaryWriter.Write((short)(num2 * 32767f));
				}
			}
		}
		return memoryStream.ToArray();
	}

	private void SaveRecording()
	{
		byte[] bytes = EncodeToWav(recordedAudioClip);
		try
		{
			File.WriteAllBytes(playerDialogueAudioPath, bytes);
		}
		catch (Exception ex)
		{
			LogError("Error saving recording: " + ex.Message);
		}
	}

	private AudioClip LoadAudioClip(string audioPath)
	{
		if (File.Exists(audioPath))
		{
			byte[] array = File.ReadAllBytes(audioPath);
			int num = BitConverter.ToInt16(array, 22);
			int frequency = BitConverter.ToInt32(array, 24);
			int num2 = 44;
			int num3 = array.Length - num2;
			float[] array2 = new float[num3 / 4];
			for (int i = 0; i < array2.Length; i++)
			{
				array2[i] = BitConverter.ToSingle(array, i * 4 + num2);
			}
			bool stream = false;
			AudioClip audioClip = AudioClip.Create("AudioClipName", array2.Length / num, num, frequency, stream);
			audioClip.SetData(array2, 0);
			return audioClip;
		}
		LogError("Audio file not found: " + audioPath);
		return null;
	}

	private void PlayRecordedAudio(string fileName)
	{
		AudioClip audioClip = LoadAudioClip(playerDialogueAudioPath);
		AudioClip audioClip2 = LoadAudioClip(npcDialogueAudioPath);
		if ((bool)audioClip && (bool)audioClip2)
		{
			CompareAudioFormats(audioClip, audioClip2);
		}
		if (audioClip != null)
		{
			AudioSource.PlayClipAtPoint(audioClip, Player.m_localPlayer.transform.position, 1f);
		}
		LogInfo("Playing last recorded clip audio");
	}

	public void MyPlayAudio(AudioClip clip)
	{
		GameObject gameObject = new GameObject("One shot audio");
		gameObject.transform.position = Player.m_localPlayer.transform.position;
		AudioSource audioSource = (AudioSource)gameObject.AddComponent(typeof(AudioSource));
		audioSource.clip = clip;
		audioSource.spatialBlend = 0f;
		audioSource.volume = instance.npcVolume / 100f;
		audioSource.bypassEffects = true;
		audioSource.bypassListenerEffects = true;
		audioSource.bypassReverbZones = true;
		audioSource.PlayOneShot(clip, 5f);
		UnityEngine.Object.Destroy(gameObject, clip.length * ((Time.timeScale < 0.01f) ? 0.01f : Time.timeScale));
	}

	public void PlayWavFile(string filePath)
	{
		if (!File.Exists(filePath))
		{
			LogError("File not found: " + filePath);
			return;
		}
		try
		{
			byte[] wavData = File.ReadAllBytes(filePath);
			AudioClip clip = WavToAudioClip(wavData, Path.GetFileNameWithoutExtension(filePath));
			MyPlayAudio(clip);
		}
		catch (Exception ex)
		{
			LogError("Error playing WAV file: " + ex.Message);
		}
	}

	private AudioClip WavToAudioClip(byte[] wavData, string clipName)
	{
		int num = BitConverter.ToInt16(wavData, 22);
		int frequency = BitConverter.ToInt32(wavData, 24);
		int num2 = BitConverter.ToInt16(wavData, 34);
		int num3 = 12;
		while (wavData[num3] != 100 || wavData[num3 + 1] != 97 || wavData[num3 + 2] != 116 || wavData[num3 + 3] != 97)
		{
			num3 += 4;
			int num4 = BitConverter.ToInt32(wavData, num3);
			num3 += 4 + num4;
		}
		int num5 = num3 + 8;
		float[] array = new float[(wavData.Length - num5) / (num2 / 8)];
		for (int i = 0; i < array.Length; i++)
		{
			switch (num2)
			{
			case 16:
			{
				short num6 = BitConverter.ToInt16(wavData, num5 + i * 2);
				array[i] = (float)num6 / 32768f;
				break;
			}
			case 8:
				array[i] = (float)(wavData[num5 + i] - 128) / 128f;
				break;
			}
		}
		AudioClip audioClip = AudioClip.Create(clipName, array.Length / num, num, frequency, stream: false);
		audioClip.SetData(array, 0);
		return audioClip;
	}

	private void CompareAudioFormats(AudioClip firstClip, AudioClip secondClip)
	{
		Debug.Log("First Clip:");
		Debug.Log("Channels: " + firstClip.channels);
		Debug.Log("Frequency: " + firstClip.frequency);
		Debug.Log("Samples: " + firstClip.samples);
		Debug.Log("Length: " + firstClip.length);
		Debug.Log("Second Clip:");
		Debug.Log("Channels: " + secondClip.channels);
		Debug.Log("Frequency: " + secondClip.frequency);
		Debug.Log("Samples: " + secondClip.samples);
		Debug.Log("Length: " + secondClip.length);
	}

	private string GetBase64FileData(string audioPath)
	{
		if (File.Exists(audioPath))
		{
			byte[] inArray = File.ReadAllBytes(audioPath);
			return Convert.ToBase64String(inArray);
		}
		LogError("Audio file not found: " + audioPath);
		return null;
	}

	private void Follow_Start(GameObject target, string NPCDialogueMessage = "Right behind ya!")
	{
		if (PlayerNPC == null)
		{
			LogError("NPC command Follow_Start failed, PlayerNPC == null");
			return;
		}
		ThrallAI component = PlayerNPC.GetComponent<ThrallAI>();
		HumanoidNPC component2 = PlayerNPC.GetComponent<HumanoidNPC>();
		SetMonsterAIAggravated(component, Aggravated: false);
		component.SetFollowTarget(target);
		if (NPCDialogueMessage != "")
		{
			AddChatTalk(component2, "NPC", NPCDialogueMessage);
		}
		NPCCurrentCommandType = NPCCommand.CommandType.FollowPlayer;
		LogMessage("Follow_Start activated!");
	}

	private void Follow_Stop(string NPCDialogueMessage = "I'm gonna wander off on my own now!")
	{
		if (PlayerNPC == null)
		{
			LogError("NPC command Follow_Stop failed, PlayerNPC == null");
			return;
		}
		ThrallAI component = PlayerNPC.GetComponent<ThrallAI>();
		HumanoidNPC component2 = PlayerNPC.GetComponent<HumanoidNPC>();
		SetMonsterAIAggravated(component, Aggravated: false);
		component.SetFollowTarget(null);
		AddChatTalk(component2, "NPC", NPCDialogueMessage);
		NPCCurrentCommandType = NPCCommand.CommandType.Idle;
		LogMessage("Follow_Stop activated!");
	}

	private void Combat_StartAttacking(string EnemyName, string NPCDialogueMessage = "Watch out, here I come!")
	{
		if (PlayerNPC == null)
		{
			LogError("NPC command Combat_StartAttacking failed, PlayerNPC == null");
			return;
		}
		if (NPCCurrentMode == NPCMode.Passive)
		{
			NPCCurrentMode = NPCMode.Defensive;
		}
		ThrallAI component = PlayerNPC.GetComponent<ThrallAI>();
		HumanoidNPC component2 = PlayerNPC.GetComponent<HumanoidNPC>();
		CurrentEnemyName = EnemyName;
		GameObject gameObject = null;
		if (EnemyName != "")
		{
			LogInfo("Trying to find enemy " + EnemyName);
			Character character = FindClosestEnemy(component2.gameObject);
			if (!character)
			{
				LogError("Combat_StartAttacking, findclosestenemy returned null");
				return;
			}
			component.SetFollowTarget(null);
			component.m_targetCreature = null;
			component.SetTarget(character);
			component.m_updateTargetTimer = 1000000f;
		}
		else
		{
			LogError("EnemyName was null");
		}
		if (NPCDialogueMessage != "")
		{
			AddChatTalk(component2, "NPC", NPCDialogueMessage);
		}
		NPCCurrentCommandType = NPCCommand.CommandType.CombatAttack;
		LogMessage("Combat_StartAttacking activated!");
	}

	private void Combat_StartSneakAttacking(GameObject target, string NPCDialogueMessage = "Sneaking up on em!")
	{
		if (PlayerNPC == null)
		{
			LogError("NPC command Combat_StartSneakAttacking failed, PlayerNPC == null");
			return;
		}
		ThrallAI component = PlayerNPC.GetComponent<ThrallAI>();
		HumanoidNPC component2 = PlayerNPC.GetComponent<HumanoidNPC>();
		component.SetFollowTarget(null);
		((BaseAI)component).m_alerted = false;
		component.m_aggravatable = true;
		component.SetHuntPlayer(hunt: true);
		component2.SetCrouch(crouch: true);
		AddChatTalk(component2, "NPC", NPCDialogueMessage);
		NPCCurrentCommandType = NPCCommand.CommandType.CombatSneakAttack;
		LogMessage("Combat_StartSneakAttacking activated!");
	}

	private void Combat_StartDefending(GameObject target, string NPCDialogueMessage = "Don't worry, I'm here with you!")
	{
		if (PlayerNPC == null)
		{
			LogError("NPC command Combat_StartDefending failed, PlayerNPC == null");
			return;
		}
		ThrallAI component = PlayerNPC.GetComponent<ThrallAI>();
		HumanoidNPC component2 = PlayerNPC.GetComponent<HumanoidNPC>();
		component.SetFollowTarget(null);
		SetMonsterAIAggravated(component, Aggravated: false);
		AddChatTalk(component2, "NPC", NPCDialogueMessage);
		NPCCurrentCommandType = NPCCommand.CommandType.CombatDefend;
		LogMessage("Combat_StartDefending activated!");
	}

	private void Combat_StopAttacking(string NPCDialogueMessage = "I'll give em a break!")
	{
		if (PlayerNPC == null)
		{
			LogError("NPC command Combat_StopAttacking failed, PlayerNPC == null");
			return;
		}
		ThrallAI component = PlayerNPC.GetComponent<ThrallAI>();
		HumanoidNPC component2 = PlayerNPC.GetComponent<HumanoidNPC>();
		component.SetFollowTarget(null);
		SetMonsterAIAggravated(component, Aggravated: false);
		AddChatTalk(component2, "NPC", NPCDialogueMessage);
		NPCCurrentCommandType = NPCCommand.CommandType.Idle;
		LogMessage("Combat_StopAttacking activated!");
	}

	private void Inventory_DropAll(string NPCDialogueMessage = "Here is all I got!")
	{
		if (PlayerNPC == null)
		{
			LogError("NPC command Inventory_DropAll failed, PlayerNPC == null");
			return;
		}
		ThrallAI component = PlayerNPC.GetComponent<ThrallAI>();
		HumanoidNPC component2 = PlayerNPC.GetComponent<HumanoidNPC>();
		DropAllItems(component2);
		LogMessage("Inventory_DropAll activated!");
	}

	private void Inventory_DropItem(string ItemName, string NPCDialogueMessage = "Here is what you asked for!")
	{
		if (PlayerNPC == null)
		{
			LogError("NPC command Inventory_DropItem failed, PlayerNPC == null");
			return;
		}
		ThrallAI component = PlayerNPC.GetComponent<ThrallAI>();
		HumanoidNPC component2 = PlayerNPC.GetComponent<HumanoidNPC>();
		DropItem(ItemName, component2);
		LogMessage("Inventory_DropItem activated!");
	}

	private void Inventory_EquipItem(string ItemName, string NPCDialogueMessage = "On it boss!")
	{
		if (PlayerNPC == null)
		{
			LogError("NPC command Inventory_EquipItem failed, PlayerNPC == null");
			return;
		}
		ThrallAI component = PlayerNPC.GetComponent<ThrallAI>();
		HumanoidNPC component2 = PlayerNPC.GetComponent<HumanoidNPC>();
		if (!ItemName.StartsWith("$"))
		{
			ItemName = "$" + ItemName;
		}
		CurrentWeaponName = ItemName;
		EquipItem(ItemName, component2);
		LogMessage("Inventory_EquipItem activated! ItemName : " + ItemName);
	}

	private void Harvesting_Start(string ResourceName, string NPCDialogueMessage = "On it boss!")
	{
		if (PlayerNPC == null)
		{
			LogError("NPC command Harvesting_Start failed, PlayerNPC == null");
			return;
		}
		ThrallAI component = PlayerNPC.GetComponent<ThrallAI>();
		HumanoidNPC component2 = PlayerNPC.GetComponent<HumanoidNPC>();
		CurrentHarvestResourceName = CleanKey(ResourceName);
		LogInfo("trying to harvest resource: " + CurrentHarvestResourceName);
		ResourceNodes = QueryResourceComplete(CurrentHarvestResourceName, HasWeapon: false);
		ResourceNodesNamesOnly = ConvertResourcesToNames(ResourceNodes.Values.ToList());
		ResourceNodesOneArray = FlattenListOfLists(ResourceNodesNamesOnly);
		if (NPCDialogueMessage != "")
		{
			AddChatTalk(component2, "NPC", NPCDialogueMessage);
		}
		NPCCurrentCommandType = NPCCommand.CommandType.HarvestResource;
		LogMessage("Harvesting_Start activated!");
	}

	private void Harvesting_Stop(string NPCDialogueMessage = "No more labor!")
	{
		if (PlayerNPC == null)
		{
			LogError("NPC command Harvesting_Stop failed, PlayerNPC == null");
			return;
		}
		ThrallAI component = PlayerNPC.GetComponent<ThrallAI>();
		HumanoidNPC component2 = PlayerNPC.GetComponent<HumanoidNPC>();
		component.SetFollowTarget(null);
		AddChatTalk(component2, "NPC", NPCDialogueMessage);
		NPCCurrentCommandType = NPCCommand.CommandType.Idle;
		LogMessage("Harvesting_Stop activated!");
	}

	private void Patrol_Start(string NPCDialogueMessage = "I'm keeping guard around here! They know not to try!")
	{
		if (PlayerNPC == null)
		{
			LogError("NPC command Patrol_Start failed, PlayerNPC == null");
			return;
		}
		ThrallAI component = PlayerNPC.GetComponent<ThrallAI>();
		HumanoidNPC component2 = PlayerNPC.GetComponent<HumanoidNPC>();
		patrol_position = Player.m_localPlayer.transform.position;
		instance.patrol_harvest = true;
		component.SetFollowTarget(null);
		SetMonsterAIAggravated(component, Aggravated: false);
		SetMonsterAIAggravated(component, Aggravated: true);
		if (NPCDialogueMessage != "")
		{
			AddChatTalk(component2, "NPC", NPCDialogueMessage);
		}
		NPCCurrentCommandType = NPCCommand.CommandType.PatrolArea;
		LogMessage("Patrol_Start activated!");
	}

	private void Patrol_Stop(string NPCDialogueMessage = "My job is done here!")
	{
		if (PlayerNPC == null)
		{
			LogError("NPC command Patrol_Stop failed, PlayerNPC == null");
			return;
		}
		ThrallAI component = PlayerNPC.GetComponent<ThrallAI>();
		HumanoidNPC component2 = PlayerNPC.GetComponent<HumanoidNPC>();
		component.SetFollowTarget(null);
		AddChatTalk(component2, "NPC", NPCDialogueMessage);
		NPCCurrentCommandType = NPCCommand.CommandType.Idle;
		LogMessage("Patrol_Stop activated!");
	}

	private void SendRecordingToBrain()
	{
		if (IsRecording)
		{
			instance.StopRecording();
		}
		if ((bool)PlayerNPC)
		{
			ThrallAI component = PlayerNPC.GetComponent<ThrallAI>();
			HumanoidNPC component2 = PlayerNPC.GetComponent<HumanoidNPC>();
			BrainSendInstruction(PlayerNPC);
			lastSentToBrainTime = Time.time;
			AddChatTalk(component2, "NPC", "...");
		}
	}

	private async Task SendLogToBrain()
	{
		if (logEntries.Count <= 0 || !LogToBrain.Value)
		{
			return;
		}
		StringBuilder res = new StringBuilder();
		foreach (string entry in logEntries)
		{
			res.AppendLine(entry);
		}
		JsonObject jObject = new JsonObject
		{
			["player_id"] = GetPlayerSteamID(),
			["timestamp"] = DateTime.Now.ToString(),
			["log_string"] = res.ToString()
		};
		WebClient webClient = new WebClient();
		webClient.Headers.Add("Content-Type", "application/json");
		webClient.UploadStringCompleted += OnSendLogToBrainCompleted;
		try
		{
			Task timeoutTask = Task.Delay(TimeSpan.FromSeconds(10.0));
			Task<string> uploadTask = webClient.UploadStringTaskAsync(new Uri(GetBrainAPIAddress() + "/log_valheim"), IndentJson(((object)jObject).ToString()));
			if (await Task.WhenAny(uploadTask, timeoutTask) == timeoutTask)
			{
				webClient.CancelAsync();
				throw new TimeoutException("Request timed out after 10 seconds");
			}
			await uploadTask;
			LogInfo("Successfully logged to brain!");
		}
		catch (WebException ex)
		{
			LogError("Error connecting to server/log: " + ex.Message);
		}
		catch (TimeoutException ex2)
		{
			LogError("Request timed out /log: " + ex2.Message);
		}
		catch (Exception ex3)
		{
			LogError("An error occurred /log: " + ex3.Message);
		}
		logEntries.Clear();
	}

	private void OnSendLogToBrainCompleted(object sender, UploadStringCompletedEventArgs e)
	{
		if (e.Error == null)
		{
			LogInfo("Logged to brain completed!");
		}
		else
		{
			LogError("Sending log to brain failed: " + e.Error.Message);
		}
	}

	public void BrainSynthesizeAudio(string text, string voice)
	{
		using WebClient webClient = new WebClient();
		string uriString = ((!cartesiaVoices.Contains(npcVoices[instance.npcVoice])) ? (GetBrainAPIAddress() + "/synthesize_audio?text=" + Uri.EscapeDataString(text) + "&voice=" + Uri.EscapeDataString(voice) + "&player_id=" + GetPlayerSteamID()) : (GetBrainAPIAddress() + "/synthesize_audio?text=" + Uri.EscapeDataString(text) + "&voice=" + Uri.EscapeDataString(npcVoices[instance.npcVoice]) + "&use_cartesia=true&player_id=" + GetPlayerSteamID()));
		webClient.DownloadStringCompleted += OnBrainSynthesizeAudioResponse;
		webClient.DownloadStringAsync(new Uri(uriString));
	}

	private void OnBrainSynthesizeAudioResponse(object sender, DownloadStringCompletedEventArgs e)
	{
		if (e.Error != null)
		{
			LogError("Synthesize Audio Download failed: " + e.Error.Message);
			return;
		}
		try
		{
			JsonObject val = SimpleJson.DeserializeObject<JsonObject>(e.Result);
			string audioFileId = val["audio_file_id"].ToString();
			string text = val["text"].ToString();
			HumanoidNPC component = PlayerNPC.GetComponent<HumanoidNPC>();
			DownloadAudioFile(audioFileId);
		}
		catch (Exception ex)
		{
			LogError("Failed to parse Synthesize Audio Download JSON: " + ex.Message);
		}
		instance.previewVoiceButton.SetActive(value: true);
		SetPreviewVoiceButtonState(instance.previewVoiceButtonComp, interactable: true, 1f);
	}

	private async Task BrainSendPeriodicUpdate(GameObject npc)
	{
		string jsonData = GetJSONForBrain(npc, includeRecordedAudio: false);
		WebClient webClient = new WebClient();
		webClient.Headers.Add("Content-Type", "application/json");
		webClient.UploadStringCompleted += OnBrainSendInstructionResponse;
		try
		{
			Task timeoutTask = Task.Delay(TimeSpan.FromSeconds(10.0));
			Task<string> uploadTask = webClient.UploadStringTaskAsync(new Uri(GetBrainAPIAddress() + "/instruct_agent"), jsonData);
			if (await Task.WhenAny(uploadTask, timeoutTask) == timeoutTask)
			{
				webClient.CancelAsync();
				throw new TimeoutException("BrainSendPeriodicUpdate | Request timed out after 10 seconds");
			}
			await uploadTask;
		}
		catch (WebException ex)
		{
			WebException ex2 = ex;
			LogError("BrainSendPeriodicUpdate | Error connecting to server: " + ex2.Message);
			MessageHud.instance.ShowMessage(MessageHud.MessageType.Center, "Error connecting to Thrall server!", 0, (Sprite)null);
		}
		catch (TimeoutException ex3)
		{
			TimeoutException ex4 = ex3;
			LogError("BrainSendPeriodicUpdate | Request timed out: " + ex4.Message);
			MessageHud.instance.ShowMessage(MessageHud.MessageType.Center, "Timeout error while connecting to Thrall server!", 0, (Sprite)null);
		}
		catch (Exception ex5)
		{
			Exception ex6 = ex5;
			LogError("BrainSendPeriodicUpdate | An error occurred: " + ex6.Message);
			MessageHud.instance.ShowMessage(MessageHud.MessageType.Center, "An error occurred while trying to connect to Thrall server!", 0, (Sprite)null);
		}
	}

	private void OnBrainSendPeriodicUpdateResponse(object sender, UploadStringCompletedEventArgs e)
	{
		if (e.Error == null)
		{
			string result = e.Result;
			JsonObject val = SimpleJson.DeserializeObject<JsonObject>(result);
			string text = val["agent_text_response_audio_file_id"].ToString();
			string text2 = val["agent_text_response"].ToString();
			string text3 = val["player_instruction_transcription"].ToString();
			object obj = val["agent_commands"];
			JsonArray val2 = (JsonArray)((obj is JsonArray) ? obj : null);
			if (val2 != null && ((List<object>)(object)val2).Count > 0)
			{
				for (int i = 0; i < ((List<object>)(object)val2).Count; i++)
				{
					object obj2 = ((List<object>)(object)val2)[i];
					JsonObject val3 = (JsonObject)((obj2 is JsonObject) ? obj2 : null);
					if (!val3.ContainsKey("action") || !val3.ContainsKey("category"))
					{
						HumanoidNPC component = PlayerNPC.GetComponent<HumanoidNPC>();
						AddChatTalk(component, "NPC", text2);
						LogError("Agent command response from brain was incomplete. Command's Action or Category is missing!");
						continue;
					}
					string text4 = val3["action"].ToString();
					string text5 = val3["category"].ToString();
					string[] array = new string[0];
					string text6 = "";
					if (val3.ContainsKey("parameters"))
					{
						object obj3 = val3["parameters"];
						JsonArray val4 = (JsonArray)((obj3 is JsonArray) ? obj3 : null);
						if (val4 != null && ((List<object>)(object)val4).Count > 0)
						{
							text6 = ((List<object>)(object)val4)[0].ToString();
						}
					}
					string[] array2 = array;
					foreach (string text7 in array2)
					{
						LogError("param " + text7);
					}
					Debug.Log("NEW COMMAND: Category: " + text5 + ". Action : " + text4 + ". Parameters: " + array);
					ProcessNPCCommand(text5, text4, text6, text2);
					Sprite icon = Sprite.Create(Texture2D.whiteTexture, new Rect(0f, 0f, 1f, 1f), Vector2.one * 0.5f);
					AddItemToScrollBox(TaskListScrollBox, text4 + " " + text5 + " (" + text6 + ")", icon, 0);
				}
			}
			else
			{
				HumanoidNPC component2 = PlayerNPC.GetComponent<HumanoidNPC>();
				AddChatTalk(component2, "NPC", text2);
				Debug.Log("No agent commands found.");
			}
			Debug.Log("Brain periodic update response: " + result);
		}
		else
		{
			Debug.LogError("Request failed: " + e.Error.Message);
		}
	}

	private static void StartBrainPeriodicUpdateTimer()
	{
		instance.SetTimer(UnityEngine.Random.Range(5, 12), delegate
		{
			Debug.LogError("BrainPeriodicUpdateTimer");
			if ((bool)PlayerNPC && (double)UnityEngine.Random.value > 0.5)
			{
				instance.BrainSendInstruction(PlayerNPC, Voice: false);
			}
			StartBrainPeriodicUpdateTimer();
		});
	}

	private async Task BrainSendInstruction(GameObject npc, bool Voice = true)
	{
		string jsonData = GetJSONForBrain(npc, Voice);
		WebClient webClient = new WebClient();
		webClient.Headers.Add("Content-Type", "application/json");
		webClient.UploadStringCompleted += OnBrainSendInstructionResponse;
		try
		{
			Task timeoutTask = Task.Delay(TimeSpan.FromSeconds(10.0));
			Task<string> uploadTask = webClient.UploadStringTaskAsync(new Uri(GetBrainAPIAddress() + "/instruct_agent"), jsonData);
			if (await Task.WhenAny(uploadTask, timeoutTask) == timeoutTask)
			{
				webClient.CancelAsync();
				throw new TimeoutException("Request timed out after 10 seconds");
			}
			await uploadTask;
		}
		catch (WebException ex)
		{
			WebException ex2 = ex;
			LogError("Brain Send Instruction | Error connecting to server: " + ex2.Message);
			MessageHud.instance.ShowMessage(MessageHud.MessageType.Center, "Error connecting to Thrall server!", 0, (Sprite)null);
		}
		catch (TimeoutException ex3)
		{
			TimeoutException ex4 = ex3;
			LogError("Brain Send Instruction | Request timed out: " + ex4.Message);
			MessageHud.instance.ShowMessage(MessageHud.MessageType.Center, "Timeout error while connecting to Thrall server!", 0, (Sprite)null);
		}
		catch (Exception ex5)
		{
			Exception ex6 = ex5;
			LogError("Brain Send Instruction | An error occurred: " + ex6.Message);
			MessageHud.instance.ShowMessage(MessageHud.MessageType.Center, "An error occurred while trying to connect to Thrall server!", 0, (Sprite)null);
		}
	}

	private void OnBrainSendInstructionResponse(object sender, UploadStringCompletedEventArgs e)
	{
		if (e.Error == null && (bool)PlayerNPC)
		{
			string text = IndentJson(e.Result);
			JsonObject val = SimpleJson.DeserializeObject<JsonObject>(text);
			string audioFileId = val["agent_text_response_audio_file_id"].ToString();
			string text2 = val["agent_text_response"].ToString().TrimStart('\n');
			string text3 = val["player_instruction_transcription"].ToString();
			LogInfo("Full response from brain: " + text);
			LogMessage("You said: " + text3);
			LogMessage("NPC said: " + text2);
			object obj = val["agent_commands"];
			JsonArray val2 = (JsonArray)((obj is JsonArray) ? obj : null);
			if ((bool)PlayerNPC && val2 != null && ((List<object>)(object)val2).Count > 0)
			{
				for (int i = 0; i < ((List<object>)(object)val2).Count; i++)
				{
					object obj2 = ((List<object>)(object)val2)[i];
					JsonObject val3 = (JsonObject)((obj2 is JsonObject) ? obj2 : null);
					HumanoidNPC component = PlayerNPC.GetComponent<HumanoidNPC>();
					AddChatTalk(Player.m_localPlayer, "Player", text3);
					AddChatTalk(component, "NPC", text2);
					if (!val3.ContainsKey("action") || !val3.ContainsKey("category"))
					{
						LogError("Agent command response from brain was incomplete. Command's Action or Category is missing!");
						continue;
					}
					string text4 = val3["action"].ToString();
					string text5 = val3["category"].ToString();
					string[] array = new string[0];
					string text6 = "";
					if (val3.ContainsKey("parameters"))
					{
						object obj3 = val3["parameters"];
						JsonArray source = (JsonArray)((obj3 is JsonArray) ? obj3 : null);
						array = ((IEnumerable<object>)source).Select((object x) => x.ToString()).ToArray();
					}
					string[] array2 = array;
					foreach (string text7 in array2)
					{
						text6 = text6 + text7 + ", ";
					}
					LogInfo("NEW COMMAND: " + text5 + " " + text4 + " " + text6);
					if (text5 == "Inventory")
					{
						ProcessNPCCommand(text5, text4, (array.Length != 0) ? array[0] : "", text2);
					}
					Sprite sprite = Sprite.Create(Texture2D.whiteTexture, new Rect(0f, 0f, 1f, 1f), Vector2.one * 0.5f);
					switch (text5)
					{
					case "Harvesting":
					{
						string resourceName = null;
						int num4 = 0;
						string text9 = null;
						if (array.Length != 0)
						{
							int num5 = 0;
							while (i < array.Length && num5 <= 2)
							{
								int result2;
								if (num5 == 0)
								{
									resourceName = array[num5];
								}
								else if (int.TryParse(array[num5].Trim('\''), out result2))
								{
									num4 = result2;
								}
								else
								{
									text9 = array[num5];
								}
								num5++;
							}
							if (num4 < 1)
							{
								num4 = 1;
							}
							HarvestAction harvestAction = new HarvestAction();
							harvestAction.humanoidNPC = component;
							harvestAction.ResourceName = resourceName;
							harvestAction.RequiredAmount = num4;
							harvestAction.OriginalRequiredAmount = num4;
							instance.commandManager.AddCommand(harvestAction);
						}
						else
						{
							LogError("Brain gave Harvesting command but didn't give 3 parameters");
						}
						break;
					}
					case "Patrol":
					{
						PatrolAction patrolAction = new PatrolAction();
						patrolAction.humanoidNPC = component;
						patrolAction.patrol_position = Player.m_localPlayer.transform.position;
						patrolAction.patrol_radius = 15;
						instance.commandManager.AddCommand(patrolAction);
						break;
					}
					case "Combat":
					{
						string targetName = null;
						string text8 = null;
						int num2 = 1;
						if (array.Length != 0)
						{
							int num3 = 0;
							while (i < array.Length && num3 <= 2)
							{
								int result;
								if (num3 == 0)
								{
									targetName = array[num3];
								}
								else if (int.TryParse(array[num3].Trim('\''), out result))
								{
									num2 = result;
								}
								else
								{
									text8 = array[num3];
								}
								num3++;
							}
							if (num2 < 1)
							{
								num2 = 1;
							}
							AttackAction attackAction = new AttackAction();
							attackAction.humanoidNPC = component;
							attackAction.TargetName = targetName;
							attackAction.TargetQuantity = num2;
							attackAction.OriginalTargetQuantity = num2;
							instance.commandManager.AddCommand(attackAction);
						}
						else
						{
							LogError("Brain gave Combat command but didn't give a parameters");
						}
						break;
					}
					}
					if (text5 == "Follow")
					{
						FollowAction followAction = new FollowAction();
						followAction.humanoidNPC = component;
						instance.commandManager.AddCommand(followAction);
					}
				}
				RefreshTaskList();
			}
			else
			{
				HumanoidNPC component2 = PlayerNPC.GetComponent<HumanoidNPC>();
				AddChatTalk(Player.m_localPlayer, "Player", text3);
				AddChatTalk(component2, "NPC", text2);
				LogInfo("No agent commands sent by brain.");
			}
			DownloadAudioFile(audioFileId);
		}
		else
		{
			LogError("Request failed: " + e.Error.Message);
		}
	}

	private void DownloadAudioFile(string audioFileId)
	{
		WebClient webClient = new WebClient();
		webClient.DownloadDataAsync(new Uri(GetBrainAPIAddress() + "/get_audio_file?audio_file_id=" + audioFileId + "&player_id=" + GetPlayerSteamID()));
		webClient.DownloadDataCompleted += OnAudioFileDownloaded;
	}

	private void OnAudioFileDownloaded(object sender, DownloadDataCompletedEventArgs e)
	{
		if (e.Error == null)
		{
			File.WriteAllBytes(npcDialogueRawAudioPath, e.Result);
			if (lastSentToBrainTime > 0f)
			{
				LogInfo("Brain response time: " + (Time.time - lastSentToBrainTime));
			}
			PlayWavFile(npcDialogueRawAudioPath);
		}
		else if (e.Error is WebException { Status: WebExceptionStatus.ProtocolError } ex && ((HttpWebResponse)ex.Response).StatusCode == HttpStatusCode.NotFound)
		{
			LogError("Audio file does not exist. Error: " + e.Error.Message);
		}
		else
		{
			LogError("Download failed: " + e.Error.Message);
		}
	}

	private void ProcessNPCCommand(string category, string action, string parameter, string agent_text_response)
	{
		Player localPlayer = Player.m_localPlayer;
		if (category == "Inventory")
		{
			switch (action)
			{
			case "DropAll":
				instance.Inventory_DropAll(agent_text_response);
				break;
			case "DropItem":
				instance.Inventory_DropItem(parameter, agent_text_response);
				break;
			case "EquipItem":
				instance.Inventory_EquipItem(parameter, agent_text_response);
				break;
			case "PickupItem":
				break;
			}
		}
	}

	public static string GetJSONForBrain(GameObject character, bool includeRecordedAudio = true)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Expected O, but got Unknown
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_016c: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_0203: Expected O, but got Unknown
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Expected O, but got Unknown
		//IL_0257: Unknown result type (might be due to invalid IL or missing references)
		//IL_025c: Unknown result type (might be due to invalid IL or missing references)
		//IL_026d: Unknown result type (might be due to invalid IL or missing references)
		//IL_027f: Unknown result type (might be due to invalid IL or missing references)
		//IL_028d: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0314: Unknown result type (might be due to invalid IL or missing references)
		//IL_0343: Unknown result type (might be due to invalid IL or missing references)
		//IL_0360: Expected O, but got Unknown
		RefreshAllGameObjectInstances();
		Dictionary<string, object> dictionary = new Dictionary<string, object>();
		HumanoidNPC component = character.GetComponent<HumanoidNPC>();
		ThrallAI component2 = character.GetComponent<ThrallAI>();
		JsonArray val = new JsonArray();
		foreach (ItemDrop.ItemData item2 in ((Humanoid)component).m_inventory.m_inventory)
		{
			JsonObject item = new JsonObject
			{
				["name"] = (item2.m_dropPrefab ? item2.m_dropPrefab.name : item2.m_shared.m_name),
				["amount"] = item2.m_stack
			};
			((List<object>)(object)val).Add((object)item);
		}
		JsonObject val2 = new JsonObject
		{
			["Health"] = component.GetHealth(),
			["Stamina"] = component.m_stamina,
			["Inventory"] = val,
			["NPC_Mode"] = NPCCurrentCommandType.ToString(),
			["Alerted"] = ((BaseAI)component2).m_alerted,
			["IsCold"] = EnvMan.IsCold(),
			["IsFreezing"] = EnvMan.IsFreezing(),
			["IsWet"] = EnvMan.IsWet(),
			["currentTime"] = EnvMan.instance.GetDayFraction() * 24f,
			["currentWeather"] = EnvMan.instance.GetCurrentEnvironment().m_name,
			["currentBiome"] = Heightmap.FindBiome(character.transform.position).ToString(),
			["nearbyItems"] = instance.GetNearbyResourcesJSON(character),
			["nearbyEnemies"] = instance.GetNearbyEnemies(character)
		};
		Character targetCreature = component2.GetTargetCreature();
		if ((bool)targetCreature)
		{
			val2["targetCreature"] = targetCreature.m_name;
		}
		else if ((bool)component2.m_follow)
		{
			val2["followTarget"] = component2.m_follow.name;
		}
		JsonObject val3 = new JsonObject
		{
			["player_id"] = GetPlayerSteamID(),
			["agent_name"] = component.m_name,
			["game_state"] = val2,
			["timestamp"] = Time.time,
			["personality"] = instance.npcPersonality,
			["voice"] = (cartesiaVoices.Contains(npcVoices[instance.npcVoice]) ? npcVoices[instance.npcVoice] : npcVoices[instance.npcVoice].ToLower()),
			["use_cartesia"] = cartesiaVoices.Contains(npcVoices[instance.npcVoice]),
			["gender"] = instance.npcGender
		};
		if (includeRecordedAudio)
		{
			val3["player_instruction_audio_file_base64"] = instance.GetBase64FileData(instance.playerDialogueAudioPath);
		}
		else
		{
			val3["player_instruction_text"] = GetChatInputText();
		}
		val3["voice_or_text"] = (includeRecordedAudio ? "voice" : "text");
		string json = SimpleJson.SerializeObject((object)val3);
		json = IndentJson(json);
		val3["player_instruction_audio_file_base64"] = "";
		string json2 = SimpleJson.SerializeObject((object)val3);
		json2 = IndentJson(json2);
		LogInfo("Sending to brain: " + json2);
		return json;
	}

	private static bool CanAccessAllGameInstances()
	{
		if (Time.time > AllGOInstancesLastRefresh + (float)AllGOInstancesRefreshRate || AllGOInstancesLastRefresh == 0f)
		{
			RefreshAllGameObjectInstances();
		}
		if (AllGOInstances.Length != 0)
		{
			return true;
		}
		return false;
	}

	private static GameObject[] GetAllGameObjectInstances()
	{
		if (CanAccessAllGameInstances())
		{
			return AllGOInstances;
		}
		return null;
	}

	private static void RefreshAllGameObjectInstances()
	{
		if (!PlayerNPC && !Player.m_localPlayer)
		{
			LogError("RefreshAllGameObjectInstances failed! Local player and PlayerNPC was null");
			return;
		}
		Vector3 p = ((PlayerNPC != null) ? PlayerNPC.transform.position : Player.m_localPlayer.transform.position);
		AllGOInstances = (from go in UnityEngine.Object.FindObjectsOfType<GameObject>(includeInactive: false)
			where go != null && go.transform.position.DistanceTo(p) < 300f && !blacklistedItems.Contains(go) && (HasAnyChildComponent(go, new List<Type>
			{
				typeof(Character),
				typeof(BaseAI)
			}) || ExposedGameObjectExtension.HasAnyComponent(go, new string[9] { "ItemDrop", "CharacterDrop", "DropOnDestroyed", "Pickable", "Destructible", "TreeBase", "TreeLog", "MineRock", "MineRock5" }))
			select go).ToArray();
		AllGOInstancesLastRefresh = Time.time;
		LogInfo(string.Format("Refresh nearby objects, len {0}, 300 units from {1}", AllGOInstances.Count(), (PlayerNPC != null) ? "thrall" : "player"));
	}

	private GameObject[] FindEnemies()
	{
		if (Time.time - AllEnemiesInstancesLastRefresh < 1f)
		{
			return instance.AllEnemiesInstances;
		}
		List<Type> compsList = new List<Type>();
		compsList.Add(typeof(Character));
		instance.AllEnemiesInstances = (from go in UnityEngine.Object.FindObjectsOfType<GameObject>(includeInactive: true)
			where go != null && HasAnyChildComponent(go, compsList) && !GetCharacterFromGameObject(go).m_tamed
			select go).ToArray();
		AllEnemiesInstancesLastRefresh = Time.time;
		return instance.AllEnemiesInstances;
	}

	private static Character FindClosestEnemy(GameObject character, string EnemyName = "")
	{
		GameObject gameObject = null;
		if (EnemyName == "")
		{
			gameObject = (from t in (from go in instance.FindEnemies()
					where go != null
					select go).ToArray()
				orderby Vector3.Distance(character.transform.position, t.transform.position)
				select t).FirstOrDefault();
		}
		gameObject = (from t in (from go in instance.FindEnemies()
				where go != null && IsStringStartingWith(go.name, EnemyName, bCleanKey: true)
				select go).ToArray()
			orderby Vector3.Distance(character.transform.position, t.transform.position)
			select t).FirstOrDefault();
		return GetCharacterFromGameObject(gameObject);
	}

	private static GameObject FindPlayerNPC()
	{
		HumanoidNPC[] array = (from go in UnityEngine.Object.FindObjectsOfType<HumanoidNPC>(includeInactive: true)
			where go != null && go.name.Contains(NPCPrefabName)
			select go).ToArray();
		if (array.Length != 0)
		{
			PlayerNPC = array[0].gameObject;
			humanoid_PlayerNPC = PlayerNPC.GetComponent<HumanoidNPC>();
			thrallAI_PlayerNPC = PlayerNPC.GetComponent<ThrallAI>();
		}
		if (array.Length > 1)
		{
			for (int num = 0; num < array.Length; num++)
			{
				UnityEngine.Object.Destroy(array[num]);
			}
		}
		return PlayerNPC;
	}

	private static GameObject FindClosestResource(GameObject character, string ResourceName, bool UnderwaterAllowed = true)
	{
		if (CanAccessAllGameInstances())
		{
			return (from t in AllGOInstances.Where((GameObject go) => go != null && IsStringEqual(go.name, ResourceName) && (UnderwaterAllowed || !IsUnderwater(go.transform.position) || ExposedGameObjectExtension.HasAnyComponent(go, new string[2] { "ItemDrop", "Pickable" }))).ToArray()
				orderby Vector3.Distance(character.transform.position, t.transform.position)
				select t).FirstOrDefault();
		}
		LogError("FindClosestResource returning null for " + ResourceName);
		return null;
	}

	private static GameObject FindClosestResourceWithComponents(Vector3 position, float radius, string ResourceName, string[] componentNames, bool sortByDistance = true, bool UnderwaterAllowed = true)
	{
		if (CanAccessAllGameInstances())
		{
			IEnumerable<GameObject> source = AllGOInstances.Where((GameObject go) => go != null && IsStringEqual(go.name, ResourceName) && (UnderwaterAllowed || !IsUnderwater(go.transform.position) || ExposedGameObjectExtension.HasAnyComponent(go, componentNames)));
			if (sortByDistance)
			{
				source.OrderBy((GameObject t) => Vector3.Distance(position, t.transform.position));
			}
			return source.FirstOrDefault();
		}
		LogError("FindClosestResource returning null for " + ResourceName);
		return null;
	}

	private static bool IsUnderwater(Vector3 position)
	{
		GameObject prefab = ZNetScene.instance.GetPrefab("Fish1");
		if ((bool)prefab)
		{
			Fish component = prefab.GetComponent<Fish>();
			if ((bool)component)
			{
				return position.y < component.GetWaterLevel(position);
			}
		}
		return false;
	}

	private static Dictionary<string, int> GetNearbyResources(GameObject source)
	{
		nearbyResources.Clear();
		GameObject[] allGameObjectInstances = GetAllGameObjectInstances();
		foreach (GameObject gameObject in allGameObjectInstances)
		{
			if (gameObject != null)
			{
				ProcessResource(gameObject, gameObject.name);
			}
		}
		return nearbyResources;
		void ProcessResource(GameObject resource, string key)
		{
			key = CleanKey(key);
			if (nearbyResources.ContainsKey(key))
			{
				nearbyResources[key]++;
			}
			else
			{
				nearbyResources[key] = 1;
			}
			float num = resource.transform.position.DistanceTo(source.transform.position);
			if (nearbyResourcesDistance.ContainsKey(key))
			{
				nearbyResourcesDistance[key] = Mathf.Min(nearbyResourcesDistance[key], num);
			}
			else
			{
				nearbyResourcesDistance[key] = num;
			}
		}
	}

	private string GetNearbyResourcesJSON(GameObject source)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Expected O, but got Unknown
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Expected O, but got Unknown
		GetNearbyResources(source);
		JsonArray val = new JsonArray();
		foreach (KeyValuePair<string, int> nearbyResource in nearbyResources)
		{
			JsonObject val2 = new JsonObject();
			val2["name"] = nearbyResource.Key;
			val2["quantity"] = nearbyResource.Value;
			val2["nearestDistance"] = nearbyResourcesDistance[nearbyResource.Key];
			((List<object>)(object)val).Add((object)val2);
		}
		int num = nearbyResources.Values.Sum();
		string json = SimpleJson.SerializeObject((object)val);
		LogInfo($"Total nearby resources count: {num}");
		return IndentJson(json);
	}

	private string GetNearbyEnemies(GameObject source)
	{
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Expected O, but got Unknown
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Expected O, but got Unknown
		Character[] array = UnityEngine.Object.FindObjectsOfType<Character>(includeInactive: true);
		Humanoid[] array2 = UnityEngine.Object.FindObjectsOfType<Humanoid>(includeInactive: true);
		Character[] array3 = array;
		foreach (Character character in array3)
		{
			if (!character.name.Contains("Player") && !character.name.Contains("HumanoidNPC"))
			{
				ProcessResource(character, character.name);
			}
		}
		JsonArray val = new JsonArray();
		foreach (KeyValuePair<string, int> nearbyEnemy in nearbyEnemies)
		{
			JsonObject val2 = new JsonObject();
			val2["name"] = nearbyEnemy.Key;
			val2["quantity"] = nearbyEnemy.Value;
			val2["nearestDistance"] = nearbyEnemiesDistance[nearbyEnemy.Key];
			((List<object>)(object)val).Add((object)val2);
		}
		int num = nearbyEnemies.Values.Sum();
		string json = SimpleJson.SerializeObject((object)val);
		LogInfo($"Total nearby enemies: {num}");
		return IndentJson(json);
		void ProcessResource(Component resource, string key)
		{
			key = CleanKey(key);
			if (nearbyEnemies.ContainsKey(key))
			{
				nearbyEnemies[key]++;
			}
			else
			{
				nearbyEnemies[key] = 1;
			}
			float num2 = resource.transform.position.DistanceTo(source.transform.position);
			if (nearbyEnemiesDistance.ContainsKey(key))
			{
				nearbyEnemiesDistance[key] = Mathf.Min(nearbyEnemiesDistance[key], num2);
			}
			else
			{
				nearbyEnemiesDistance[key] = num2;
			}
		}
	}

	public static void SaveNPCData(GameObject character)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Expected O, but got Unknown
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Expected O, but got Unknown
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_018b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Expected O, but got Unknown
		//IL_01f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fe: Expected O, but got Unknown
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0157: Expected O, but got Unknown
		HumanoidNPC component = character.GetComponent<HumanoidNPC>();
		ThrallAI component2 = character.GetComponent<ThrallAI>();
		JsonObject val = new JsonObject();
		val["name"] = component.m_name;
		val["personality"] = instance.npcPersonality;
		val["voice"] = instance.npcVoice;
		val["volume"] = (int)instance.npcVolume;
		val["gender"] = instance.npcGender;
		val["MicrophoneIndex"] = instance.MicrophoneIndex;
		JsonArray val2 = new JsonArray();
		foreach (ItemDrop.ItemData item2 in ((Humanoid)component).m_inventory.m_inventory)
		{
			JsonObject item = new JsonObject
			{
				["name"] = item2.m_dropPrefab.name,
				["stack"] = item2.m_stack,
				["equipped"] = (item2.m_equipped ? 1 : 0),
				["durability"] = item2.m_durability,
				["quality"] = item2.m_quality
			};
			((List<object>)(object)val2).Add((object)item);
		}
		val["inventory"] = val2;
		JsonArray val3 = new JsonArray();
		((List<object>)(object)val3).Add((object)((Humanoid)component).m_visEquipment.m_skinColor.x);
		((List<object>)(object)val3).Add((object)((Humanoid)component).m_visEquipment.m_skinColor.y);
		((List<object>)(object)val3).Add((object)((Humanoid)component).m_visEquipment.m_skinColor.z);
		val["skinColor"] = val3;
		JsonArray val4 = new JsonArray();
		((List<object>)(object)val4).Add((object)((Humanoid)component).m_visEquipment.m_hairColor.x);
		((List<object>)(object)val4).Add((object)((Humanoid)component).m_visEquipment.m_hairColor.y);
		((List<object>)(object)val4).Add((object)((Humanoid)component).m_visEquipment.m_hairColor.z);
		val["hairColor"] = val4;
		string json = SimpleJson.SerializeObject((object)val);
		json = IndentJson(json);
		string path = Path.Combine(Application.persistentDataPath, "thrallmod.json");
		File.WriteAllText(path, json);
	}

	public static void LoadNPCData(HumanoidNPC npc)
	{
		//IL_02a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a8: Expected O, but got Unknown
		string text = Path.Combine(Application.persistentDataPath, "thrallmod.json");
		LogInfo("Loading NPC data from " + text);
		if (File.Exists(text))
		{
			string text2 = File.ReadAllText(text);
			JsonObject val = SimpleJson.DeserializeObject<JsonObject>(text2);
			if (val.ContainsKey("name"))
			{
				instance.npcName = val["name"].ToString();
			}
			if (val.ContainsKey("personality"))
			{
				instance.npcPersonality = val["personality"].ToString();
			}
			if (val.ContainsKey("voice"))
			{
				instance.npcVoice = int.Parse(val["voice"].ToString());
			}
			if (val.ContainsKey("volume"))
			{
				instance.npcVolume = int.Parse(val["volume"].ToString());
			}
			if (val.ContainsKey("gender"))
			{
				instance.npcGender = int.Parse(val["gender"].ToString());
			}
			if (val.ContainsKey("MicrophoneIndex"))
			{
				instance.MicrophoneIndex = int.Parse(val["MicrophoneIndex"].ToString());
			}
			object obj = val["skinColor"];
			JsonArray val2 = (JsonArray)((obj is JsonArray) ? obj : null);
			if (((List<object>)(object)val2).Count == 3)
			{
				instance.skinColor = new Color(float.Parse(((List<object>)(object)val2)[0].ToString()), float.Parse(((List<object>)(object)val2)[1].ToString()), float.Parse(((List<object>)(object)val2)[2].ToString()));
			}
			object obj2 = val["hairColor"];
			JsonArray val3 = (JsonArray)((obj2 is JsonArray) ? obj2 : null);
			if (((List<object>)(object)val3).Count == 3)
			{
				instance.hairColor = new Color(float.Parse(((List<object>)(object)val3)[0].ToString()), float.Parse(((List<object>)(object)val3)[1].ToString()), float.Parse(((List<object>)(object)val3)[2].ToString()));
			}
			ApplyNPCData(npc);
			object obj3 = val["inventory"];
			JsonArray val4 = (JsonArray)((obj3 is JsonArray) ? obj3 : null);
			((Humanoid)npc).m_inventory.RemoveAll();
			npc.GetInventory().RemoveAll();
			((Humanoid)npc).m_inventory.m_inventory.Clear();
			LogMessage($"Loading {((List<object>)(object)val4).Count} items to {npc.m_name}'s inventory");
			foreach (JsonObject item in (List<object>)(object)val4)
			{
				JsonObject val5 = item;
				string text3 = val5["name"].ToString();
				int stackSize = int.Parse(val5["stack"].ToString());
				int num = 0;
				if (val5.ContainsKey("equipped"))
				{
					num = int.Parse(val5["equipped"].ToString());
				}
				float num2 = 0f;
				if (val5.ContainsKey("durability"))
				{
					num2 = float.Parse(val5["durability"].ToString());
				}
				int num3 = 0;
				if (val5.ContainsKey("quality"))
				{
					num3 = int.Parse(val5["quality"].ToString());
				}
				GameObject prefab = ZNetScene.instance.GetPrefab(text3);
				if (prefab != null)
				{
					ItemDrop.ItemData itemData = npc.PickupPrefab(prefab, stackSize);
					if (num != 0)
					{
						npc.EquipItem(itemData);
					}
					if (num2 > 0f)
					{
						itemData.m_durability = num2;
					}
					if (num3 > 0)
					{
						itemData.m_quality = num3;
					}
				}
				else if (prefab == null)
				{
					LogError("itemPrefab " + text3 + " was null");
				}
			}
			npc.EquipBestWeapon(Player.m_localPlayer, null, Player.m_localPlayer, Player.m_localPlayer);
			LogMessage(npc.m_name + " data loaded successfully!");
		}
		else
		{
			LogWarning("No saved NPC data found.");
			LogMessage("Applying default NPC personality");
			instance.OnNPCPersonalityDropdownChanged(0);
			ApplyNPCData(npc);
		}
	}

	private static int FindNPCPersonalityKeyIndexForValue(string value)
	{
		KeyValuePair<string, string> keyValuePair = npcPersonalitiesMap.FirstOrDefault((KeyValuePair<string, string> kvp) => kvp.Value == value);
		if (!keyValuePair.Equals(default(KeyValuePair<string, string>)))
		{
			return Array.IndexOf(npcPersonalities.ToArray(), keyValuePair.Key);
		}
		return -1;
	}

	public static void ApplyNPCData(HumanoidNPC npc)
	{
		npc.m_name = instance.npcName;
		instance.nameInputField.SetTextWithoutNotify(instance.npcName);
		instance.personalityInputField.SetTextWithoutNotify(instance.npcPersonality);
		int num = FindNPCPersonalityKeyIndexForValue(instance.npcPersonality);
		instance.personalityDropdownComp.SetValueWithoutNotify((num == -1) ? (npcPersonalities.Count - 1) : num);
		instance.voiceDropdownComp.SetValueWithoutNotify(instance.npcVoice);
		instance.micDropdownComp.SetValueWithoutNotify(instance.MicrophoneIndex);
		instance.volumeSliderComp.SetValueWithoutNotify(instance.npcVolume);
		if (instance.npcGender == 0)
		{
			instance.toggleMasculine.isOn = true;
			instance.toggleFeminine.isOn = false;
		}
		else
		{
			instance.toggleMasculine.isOn = false;
			instance.toggleFeminine.isOn = true;
		}
		VisEquipment component = npc.GetComponent<VisEquipment>();
		component.SetModel(instance.npcGender);
		((Humanoid)npc).m_visEquipment.SetHairColor(new Vector3(instance.hairColor.r, instance.hairColor.g, instance.hairColor.b));
		((Humanoid)npc).m_visEquipment.SetSkinColor(new Vector3(instance.skinColor.r, instance.skinColor.g, instance.skinColor.b));
	}

	public static ItemDrop.ItemData GetBestHarvestingTool(List<ItemDrop.ItemData> tools, HitData.DamageModifiers resourceDamageModifiers)
	{
		return tools.OrderByDescending(CalculateEffectiveDamage).FirstOrDefault();
		static float ApplyDamageModifier(float baseDamage, HitData.DamageModifier modifier)
		{
			switch (modifier)
			{
			case HitData.DamageModifier.Normal:
				return baseDamage;
			case HitData.DamageModifier.Resistant:
				return baseDamage * 0.5f;
			case HitData.DamageModifier.Weak:
				return baseDamage * 1.5f;
			case HitData.DamageModifier.Immune:
			case HitData.DamageModifier.Ignore:
				return 0f;
			case HitData.DamageModifier.VeryResistant:
				return baseDamage * 0.25f;
			case HitData.DamageModifier.VeryWeak:
				return baseDamage * 2f;
			default:
				return baseDamage;
			}
		}
		float CalculateEffectiveDamage(ItemDrop.ItemData tool)
		{
			HitData.DamageTypes damages = tool.m_shared.m_damages;
			float num = 0f;
			if (tool.m_shared.m_skillType == Skills.SkillType.Bows)
			{
				return 0f;
			}
			num += ApplyDamageModifier(damages.m_blunt, resourceDamageModifiers.m_blunt);
			num += ApplyDamageModifier(damages.m_slash, resourceDamageModifiers.m_slash);
			num += ApplyDamageModifier(damages.m_pierce, resourceDamageModifiers.m_pierce);
			num += ApplyDamageModifier(damages.m_chop, resourceDamageModifiers.m_chop);
			num += ApplyDamageModifier(damages.m_pickaxe, resourceDamageModifiers.m_pickaxe);
			num += ApplyDamageModifier(damages.m_fire, resourceDamageModifiers.m_fire);
			num += ApplyDamageModifier(damages.m_frost, resourceDamageModifiers.m_frost);
			num += ApplyDamageModifier(damages.m_lightning, resourceDamageModifiers.m_lightning);
			num += ApplyDamageModifier(damages.m_poison, resourceDamageModifiers.m_poison);
			return num + ApplyDamageModifier(damages.m_spirit, resourceDamageModifiers.m_spirit);
		}
	}

	private float GetDamageModifierValue(HitData.DamageModifier modifier)
	{
		return modifier switch
		{
			HitData.DamageModifier.Normal => 1f, 
			HitData.DamageModifier.Resistant => 0.5f, 
			HitData.DamageModifier.Weak => 1.5f, 
			HitData.DamageModifier.Immune => 0f, 
			HitData.DamageModifier.Ignore => 1f, 
			HitData.DamageModifier.VeryResistant => 0.25f, 
			HitData.DamageModifier.VeryWeak => 2f, 
			_ => 1f, 
		};
	}

	private float CalculateWeaponEffectiveness(ItemDrop.ItemData weapon, HitData.DamageModifiers resourceModifiers)
	{
		float num = 0f;
		HitData.DamageTypes damages = weapon.m_shared.m_damages;
		if (damages.m_blunt > 0f)
		{
			num += damages.m_blunt * GetDamageModifierValue(resourceModifiers.m_blunt);
		}
		if (damages.m_slash > 0f)
		{
			num += damages.m_slash * GetDamageModifierValue(resourceModifiers.m_slash);
		}
		if (damages.m_pierce > 0f)
		{
			num += damages.m_pierce * GetDamageModifierValue(resourceModifiers.m_pierce);
		}
		if (damages.m_chop > 0f)
		{
			num += damages.m_chop * GetDamageModifierValue(resourceModifiers.m_chop);
		}
		if (damages.m_pickaxe > 0f)
		{
			num += damages.m_pickaxe * GetDamageModifierValue(resourceModifiers.m_pickaxe);
		}
		if (damages.m_fire > 0f)
		{
			num += damages.m_fire * GetDamageModifierValue(resourceModifiers.m_fire);
		}
		if (damages.m_frost > 0f)
		{
			num += damages.m_frost * GetDamageModifierValue(resourceModifiers.m_frost);
		}
		if (damages.m_lightning > 0f)
		{
			num += damages.m_lightning * GetDamageModifierValue(resourceModifiers.m_lightning);
		}
		if (damages.m_poison > 0f)
		{
			num += damages.m_poison * GetDamageModifierValue(resourceModifiers.m_poison);
		}
		if (damages.m_spirit > 0f)
		{
			num += damages.m_spirit * GetDamageModifierValue(resourceModifiers.m_spirit);
		}
		return num;
	}

	private float CalculateEfficiency(string name, string category, int minAmount, int maxAmount, float health, float weaponEffectiveness, float distance)
	{
		float num = (float)(minAmount + maxAmount) / 2f;
		if (weaponEffectiveness <= 5f)
		{
			if (category == "ItemDrop" || category == "Pickable")
			{
				return num / (1f + distance / 50f);
			}
			return 0f;
		}
		float num2 = num / (health / weaponEffectiveness);
		if (category == "ItemDrop" || category == "Pickable")
		{
			num2 = 1f;
		}
		else
		{
			switch (category)
			{
			case "DropOnDestroyed":
				num2 *= num;
				break;
			default:
				if (!(category == "Destructible"))
				{
					if (category == "CharacterDrop")
					{
						num2 *= 0.5f;
					}
					break;
				}
				goto case "TreeLog";
			case "TreeLog":
			case "TreeBase":
			case "MineRock":
			case "MineRock5":
				if (weaponEffectiveness <= 5f)
				{
					return 0f;
				}
				num2 *= num;
				if (name.ToLower().Contains("log"))
				{
					num2 *= 1.1f;
				}
				if (name.ToLower().Contains("half"))
				{
					num2 *= 1.1f;
				}
				break;
			}
		}
		float num3 = 1f / (1f + distance / 10f);
		return num2 * num3;
	}

	private void EquipBestClothes(Humanoid humanoid)
	{
		Dictionary<ItemDrop.ItemData.ItemType, ItemDrop.ItemData> dictionary = new Dictionary<ItemDrop.ItemData.ItemType, ItemDrop.ItemData>();
		foreach (ItemDrop.ItemData allItem in humanoid.m_inventory.GetAllItems())
		{
			if (IsClothing(allItem.m_shared.m_itemType) && (!dictionary.ContainsKey(allItem.m_shared.m_itemType) || allItem.GetArmor() > dictionary[allItem.m_shared.m_itemType].GetArmor()))
			{
				dictionary[allItem.m_shared.m_itemType] = allItem;
			}
		}
		foreach (KeyValuePair<ItemDrop.ItemData.ItemType, ItemDrop.ItemData> item in dictionary)
		{
			humanoid.EquipItem(item.Value);
		}
	}

	private bool IsClothing(ItemDrop.ItemData.ItemType itemType)
	{
		return itemType == ItemDrop.ItemData.ItemType.Chest || itemType == ItemDrop.ItemData.ItemType.Legs || itemType == ItemDrop.ItemData.ItemType.Helmet || itemType == ItemDrop.ItemData.ItemType.Shoulder;
	}

	private static int CountItemsInInventory(Inventory inventory, string itemName)
	{
		return (from item in inventory?.GetAllItems()
			where item.m_dropPrefab.name.ToLower() == itemName.ToLower()
			select item).Sum((ItemDrop.ItemData item) => item.m_stack) ?? 0;
	}

	private static void PrintInventoryItems(Inventory inventory)
	{
		LogMessage("Character Inventory Items:");
		List<ItemDrop.ItemData> allItems = inventory.GetAllItems();
		foreach (ItemDrop.ItemData item in allItems)
		{
			LogMessage($"- {item.m_shared.m_name} (Quantity: {item.m_stack} | {item.m_dropPrefab.name})");
		}
	}

	private static bool IsRangedWeapon(ItemDrop.ItemData item)
	{
		if (item == null)
		{
			return false;
		}
		return item.m_shared.m_itemType == ItemDrop.ItemData.ItemType.Bow || item.m_shared.m_itemType == ItemDrop.ItemData.ItemType.Torch || item.m_shared.m_attack.m_attackType == Attack.AttackType.Projectile;
	}

	private static bool IsMeleeWeapon(ItemDrop.ItemData item)
	{
		if (item == null)
		{
			return false;
		}
		return item.m_shared.m_itemType == ItemDrop.ItemData.ItemType.OneHandedWeapon || item.m_shared.m_itemType == ItemDrop.ItemData.ItemType.TwoHandedWeapon || item.m_shared.m_itemType == ItemDrop.ItemData.ItemType.TwoHandedWeaponLeft;
	}

	private static int CheckArrows(Inventory inventory)
	{
		List<ItemDrop.ItemData> list = (from item in inventory.GetAllItems()
			where item.m_shared.m_itemType == ItemDrop.ItemData.ItemType.Ammo
			select item).ToList();
		if (list.Any())
		{
			foreach (ItemDrop.ItemData item in list)
			{
			}
			return list.Count;
		}
		return 0;
	}

	private void DropAllItems(HumanoidNPC humanoidNPC)
	{
		List<ItemDrop.ItemData> allItems = ((Humanoid)humanoidNPC).m_inventory.GetAllItems();
		int num = 1;
		LogInfo($"{humanoidNPC.m_name} dropping {((Humanoid)humanoidNPC).m_inventory.GetAllItems().Count} items: ");
		foreach (ItemDrop.ItemData item in allItems)
		{
			LogInfo(item.m_shared.m_name);
			Vector3 position = humanoidNPC.transform.position + Vector3.up * 2f + UnityEngine.Random.insideUnitSphere * 0.3f + humanoidNPC.transform.forward * 2.5f;
			Quaternion rotation = Quaternion.Euler(0f, UnityEngine.Random.Range(0, 360), 0f);
			ItemDrop.DropItem(item, item.m_stack, position, rotation);
			num++;
		}
		((Humanoid)humanoidNPC).m_inventory.RemoveAll();
	}

	private void DropItem(string ItemName, HumanoidNPC humanoidNPC)
	{
		List<ItemDrop.ItemData> allItems = ((Humanoid)humanoidNPC).m_inventory.GetAllItems();
		int num = 1;
		foreach (ItemDrop.ItemData item in allItems)
		{
			if ((item.m_dropPrefab != null && ItemName == item.m_dropPrefab.name) || ItemName == item.m_shared.m_name)
			{
				LogInfo(humanoidNPC.m_name + " dropping item: " + item.m_shared.m_name);
				Vector3 position = humanoidNPC.transform.position + Vector3.up * 2f + UnityEngine.Random.insideUnitSphere * 0.3f + humanoidNPC.transform.forward * 5.5f;
				Quaternion rotation = Quaternion.Euler(0f, UnityEngine.Random.Range(0, 360), 0f);
				ItemDrop.DropItem(item, item.m_stack, position, rotation);
				num++;
				((Humanoid)humanoidNPC).m_inventory.RemoveItem(item, item.m_stack);
				return;
			}
		}
		LogInfo(humanoidNPC.m_name + " couldn't drop item: " + ItemName);
	}

	private void EquipItem(string ItemName, HumanoidNPC humanoidNPC)
	{
		List<ItemDrop.ItemData> allItems = ((Humanoid)humanoidNPC).m_inventory.GetAllItems();
		foreach (ItemDrop.ItemData item in allItems)
		{
			if (ItemName == item.m_shared.m_name)
			{
				LogInfo(humanoidNPC.m_name + " equipping  " + item.m_shared.m_name);
				humanoidNPC.EquipItem(item);
				break;
			}
		}
	}

	public void AddChatTalk(Character character, string name, string text, bool addToChat = true)
	{
		UserInfo userInfo = new UserInfo();
		if (character is Player)
		{
			Player player = (Player)character;
			userInfo.Name = player.GetPlayerName();
		}
		else
		{
			userInfo.Name = character.m_name;
		}
		Vector3 position = character.GetEyePoint() + Vector3.up * -100f;
		long senderID = ((character is Player) ? 99991 : 99992);
		Chat.WorldTextInstance worldTextInstance = Chat.instance.FindExistingWorldText(senderID);
		if (worldTextInstance != null && (bool)worldTextInstance.m_gui)
		{
			UnityEngine.Object.Destroy(worldTextInstance.m_gui);
			Chat.instance.m_worldTexts.Remove(worldTextInstance);
		}
		Chat.instance.AddInworldText(character.gameObject, senderID, position, Talker.Type.Shout, userInfo, text + "\n\n\n\n\n");
		if (text != "..." && addToChat)
		{
			Chat.instance.AddString((character is Player) ? Player.m_localPlayer.GetPlayerName() : character.m_name, text, Talker.Type.Normal);
			Chat.instance.m_hideTimer = 0f;
			Chat.instance.m_chatWindow.gameObject.SetActive(value: true);
		}
	}

	public static Vector3 GetRandomReachableLocationInRadius(Vector3 center, float radius)
	{
		Vector3 vector = UnityEngine.Random.insideUnitSphere * radius;
		Vector3 vector2 = center + vector;
		int num = 10;
		int num2 = 0;
		while (!IsLocationReachable(vector2) && num2 < num)
		{
			vector = UnityEngine.Random.insideUnitSphere * radius;
			vector2 = center + vector;
			num2++;
		}
		return vector2;
	}

	private static bool IsLocationReachable(Vector3 location)
	{
		if (Physics.SphereCast(location + Vector3.up * 500f, 0.5f, Vector3.down, out var hitInfo, 1000f, LayerMask.GetMask("Default", "static_solid", "Default_small", "Terrain")))
		{
			float num = Vector3.Distance(hitInfo.point, location);
			if (num <= 1f)
			{
				return true;
			}
		}
		return false;
	}

	private Vector3 GetRandomSpawnPosition(float radius)
	{
		Vector3 vector = Player.m_localPlayer.transform.position + Vector3.up * 20f + Vector3.forward * 20f;
		if (Physics.Raycast(vector, Vector3.down, out var hitInfo, 1000f, LayerMask.GetMask("Default", "static_solid", "Default_small", "Terrain")))
		{
			return hitInfo.point;
		}
		return vector;
	}

	public static string GetPlayerSteamID()
	{
		List<ZNet.PlayerInfo> playerList = ZNet.instance.GetPlayerList();
		int num = 0;
		if (num < playerList.Count)
		{
			return playerList[num].m_host;
		}
		return "NullID";
	}

	public static void ToggleNPCCurrentCommandType()
	{
		NPCCurrentMode = (NPCMode)((int)(NPCCurrentMode + 1) % Enum.GetValues(typeof(NPCMode)).Length);
		if (NPCCurrentMode == NPCMode.Passive)
		{
			instance.commandManager.RemoveCommandsOfType<AttackAction>();
			enemyList.Clear();
		}
	}

	private static string GetBrainAPIAddress()
	{
		return Decrypt("Ju1M0vL+9PbHCPO8Tr0Leb92JpHZZcYqtuCSwhjbizen4omyPMmvjXjfSZ9MBoCv");
	}

	public static bool IsInAWorld()
	{
		return ZNetScene.instance != null && Player.m_localPlayer != null;
	}

	public static bool IsLocalSingleplayer()
	{
		if (ZNet.instance == null)
		{
			Debug.LogWarning("ZNet instance is null. Unable to determine world type.");
			return false;
		}
		if (ZNet.instance.IsDedicated())
		{
			return false;
		}
		if (ZNet.instance.IsServer())
		{
			return ZNet.instance.GetPeers().Count <= 1;
		}
		return false;
	}

	private static void SetPassiveMode(ThrallAI __instance)
	{
		__instance.m_aggravatable = false;
		((BaseAI)__instance).m_alerted = false;
		((BaseAI)__instance).m_aggravated = false;
		__instance.m_targetCreature = null;
		__instance.SetHuntPlayer(hunt: false);
		__instance.m_viewRange = 0f;
	}

	private static void SetDefensiveMode(ThrallAI __instance)
	{
		if (enemyList.Count > 0)
		{
			__instance.m_viewRange = 80f;
			Character character = enemyList.FirstOrDefault((Character go) => go != null);
			if (character != null)
			{
				__instance.SetTarget(character);
				__instance.m_updateTargetTimer = float.MaxValue;
				LogError("New enemy in defensive mode: " + character.name);
				__instance.m_aggravatable = true;
				__instance.SetHuntPlayer(hunt: true);
			}
		}
	}

	private static void SetAggressiveMode(ThrallAI __instance)
	{
		__instance.m_aggravatable = true;
		((BaseAI)__instance).m_alerted = true;
		((BaseAI)__instance).m_aggravated = true;
		__instance.SetHuntPlayer(hunt: true);
		__instance.m_viewRange = 80f;
	}

	private static void SetMonsterAIAggravated(ThrallAI thrallAIcomp, bool Aggravated)
	{
		if (Aggravated)
		{
			thrallAIcomp.m_aggravatable = true;
			return;
		}
		((BaseAI)thrallAIcomp).m_aggravated = false;
		thrallAIcomp.m_aggravatable = false;
		((BaseAI)thrallAIcomp).m_alerted = false;
		thrallAIcomp.m_eventCreature = false;
		thrallAIcomp.m_targetCreature = null;
		thrallAIcomp.m_targetStatic = null;
		thrallAIcomp.SetHuntPlayer(hunt: false);
	}

	private static Player GetLocalPlayerOrNull()
	{
		return Player.m_localPlayer ? Player.m_localPlayer : null;
	}

	private static void AutoPickupItems()
	{
	}

	private static bool HandleEnemies(ThrallAI __instance)
	{
		__instance.m_viewRange = 80f;
		if (__instance.m_targetCreature == null || !enemyList.Contains(__instance.m_targetCreature))
		{
			if (__instance.m_targetCreature == null)
			{
				LogError("__instance.m_targetCreature == null");
			}
			else if (!enemyList.Contains(__instance.m_targetCreature))
			{
				LogError($"{enemyList.Count} !enemyList.Contains(__instance.m_targetCreature.gameObject)");
			}
			_ = from go in enemyList
				where go != null
				orderby go.transform.position.DistanceTo(__instance.transform.position)
				select go;
			Character[] array = enemyList.ToArray();
			foreach (Character character in array)
			{
				if ((bool)character)
				{
					Character character2 = character;
					if (character2 != null)
					{
						__instance.m_targetCreature = null;
						__instance.SetTarget(character2);
						__instance.m_updateTargetTimer = 1000000f;
						LogError("New enemy in defensive mode: " + character2.name);
						((BaseAI)__instance).m_alerted = true;
						__instance.m_aggravatable = true;
						__instance.SetHuntPlayer(hunt: true);
						return true;
					}
					LogError("Defensive mode enemy from enemyList wasn't a character");
				}
			}
			if (!__instance.m_targetCreature && enemyList.Count > 0)
			{
				enemyList.Clear();
				LogError("enemy list cleared");
			}
		}
		return false;
	}

	private static void PreProcessCommand()
	{
		NPCCommand nextCommand = instance.commandManager.GetNextCommand();
		if (NPCCurrentCommand == null || (nextCommand != null && NPCCurrentCommand != nextCommand))
		{
			NPCCurrentCommand = nextCommand;
			if (nextCommand is HarvestAction)
			{
				HarvestAction harvestAction = (HarvestAction)nextCommand;
				instance.Harvesting_Start(harvestAction.ResourceName, "");
			}
			if (nextCommand is PatrolAction)
			{
				PatrolAction patrolAction = (PatrolAction)nextCommand;
				instance.Patrol_Start("");
			}
			if (nextCommand is AttackAction)
			{
				AttackAction attackAction = (AttackAction)nextCommand;
				instance.Combat_StartAttacking(attackAction.TargetName, "");
			}
			if (nextCommand is FollowAction)
			{
				FollowAction followAction = (FollowAction)nextCommand;
				instance.Follow_Start(Player.m_localPlayer.gameObject, "");
			}
		}
		if (nextCommand == null && instance.commandManager.GetCommandsCount() == 0)
		{
			FollowAction command = new FollowAction();
			instance.commandManager.AddCommand(command);
		}
	}

	private static bool ProcessPatrolCommand(ThrallAI __instance, HumanoidNPC humanoidNPC)
	{
		float num = __instance.transform.position.DistanceTo(patrol_position);
		if (num > chaseUntilPatrolRadiusDistance && !MovementLock)
		{
			SetMonsterAIAggravated(__instance, Aggravated: false);
			MovementLock = true;
			LogInfo($"{humanoidNPC.m_name} went too far ({chaseUntilPatrolRadiusDistance}m away) from patrol position, heading back now!");
		}
		else if (num < instance.patrol_radius - 3f)
		{
			MovementLock = false;
			__instance.m_lastKnownTargetPos = patrol_position;
		}
		else if (num < instance.patrol_radius)
		{
			__instance.m_aggravatable = true;
		}
		if (MovementLock)
		{
			((BaseAI)__instance).MoveTo(Time.deltaTime, patrol_position, 0f, run: false);
			return false;
		}
		GameObject follow = __instance.m_follow;
		if (follow != null && (ExposedGameObjectExtension.HasAnyComponent(follow, new string[1] { "Character" }) || ExposedGameObjectExtension.HasAnyComponent(follow, new string[1] { "Humanoid" })))
		{
			return true;
		}
		if (instance.patrol_harvest)
		{
			if (follow == null || follow.transform.position.DistanceTo(patrol_position) > chaseUntilPatrolRadiusDistance || (!ExposedGameObjectExtension.HasAnyComponent(follow, new string[1] { "Pickable" }) && !ExposedGameObjectExtension.HasAnyComponent(follow, new string[1] { "ItemDrop" })))
			{
				List<Pickable> list = SphereSearchForGameObjectsWithComponent<Pickable>(patrol_position, chaseUntilPatrolRadiusDistance - 2f);
				if (list.Count == 0)
				{
					LogMessage(humanoidNPC.m_name + " has picked up all dropped items around the patrolling area. Only keeping guard now!");
					instance.patrol_harvest = false;
					return true;
				}
				foreach (Pickable item in list)
				{
					if (item == null)
					{
						LogMessage(humanoidNPC.m_name + " has picked up all dropped items around the patrolling area. Only keeping guard now!");
						instance.patrol_harvest = false;
						return true;
					}
					if (item.transform.position.DistanceTo(patrol_position) < chaseUntilPatrolRadiusDistance)
					{
						LogMessage($"{humanoidNPC.m_name} is going to pickup {item.name} in patrol area, distance: {item.transform.position.DistanceTo(__instance.transform.position)}");
						__instance.SetFollowTarget(item.gameObject);
						return true;
					}
					LogInfo("Closest pickable's distance is too far!");
				}
			}
			return true;
		}
		((BaseAI)__instance).RandomMovementArroundPoint(Time.deltaTime, patrol_position, 7f, run: false);
		return false;
	}

	private static void ProcessHarvestCommand(ThrallAI __instance, HumanoidNPC humanoidNPC)
	{
		if ((!(__instance.m_follow == null) || !(__instance.m_targetCreature == null)) && (!__instance.m_follow || ResourceNodesOneArray.Contains(CleanKey(__instance.m_follow.name))) && !(__instance.m_follow == Player.m_localPlayer))
		{
			return;
		}
		ItemDrop.ItemData currentWeapon = humanoidNPC.GetCurrentWeapon();
		List<(string, string, float, float, int)> source = instance.FindResourceSourcesRecursive(CurrentHarvestResourceName, currentWeapon);
		source = source.OrderByDescending<(string, string, float, float, int), float>(((string Category, string Name, float Efficiency, float Distance, int Depth) s) => s.Efficiency).ToList();
		bool flag = false;
		foreach (var item in source)
		{
			if (flag)
			{
				continue;
			}
			GameObject gameObject = FindClosestResource(PlayerNPC, item.Item2, UnderwaterAllowed: false);
			if (!(gameObject != null))
			{
				continue;
			}
			if (item.Item1 == "CharacterDrop")
			{
				Character characterFromGameObject = GetCharacterFromGameObject(gameObject);
				if (characterFromGameObject != null)
				{
					__instance.m_targetCreature = null;
					__instance.SetTarget(characterFromGameObject);
					__instance.m_updateTargetTimer = 1000000f;
					LogMessage(humanoidNPC.m_name + " is going to harvest " + gameObject.name + " by killing " + characterFromGameObject.name);
					flag = true;
				}
				else
				{
					LogError("Harvesting failed! Closest resource was a CharacterDrop but has no Character component");
				}
			}
			else
			{
				__instance.SetFollowTarget(gameObject);
				LogMessage(humanoidNPC.m_name + " is going to harvest " + gameObject.name);
				flag = true;
			}
		}
		if (!flag)
		{
			LogMessage("Couldnt find any resources to harvest for " + CurrentHarvestResourceName);
			LogInfo("Removing harvest " + CurrentHarvestResourceName + " command");
			CurrentHarvestResourceName = "Wood";
			instance.commandManager.RemoveCommand(0);
		}
	}

	private static void ProcessCombatCommand(ThrallAI __instance)
	{
		if (__instance.m_targetCreature == null || (!IsStringStartingWith(CurrentEnemyName, __instance.m_targetCreature.name, bCleanKey: true) && !enemyList.Contains(__instance.m_targetCreature)))
		{
			Character character = FindClosestEnemy(__instance.gameObject, CurrentEnemyName);
			if ((bool)character)
			{
				__instance.m_targetCreature = null;
				__instance.SetTarget(character);
				__instance.m_updateTargetTimer = 1000000f;
				LogMessage("CombatAttack new target set: " + CleanKey(character.name));
			}
			else
			{
				instance.commandManager.RemoveCommand(0);
				LogError("CommandType.CombatAttack, findclosestenemy returned null. Probably no more targets in the area. Removing combat command");
			}
		}
	}

	private static void ProcessFollowCommand(ThrallAI __instance)
	{
		if ((bool)__instance.m_follow && __instance.m_follow != Player.m_localPlayer.gameObject && !ExposedGameObjectExtension.HasAnyComponent(__instance.m_follow, new string[2] { "ItemDrop", "Pickable" }) && enemyList.Count == 0)
		{
			__instance.SetFollowTarget(Player.m_localPlayer.gameObject);
			LogMessage("Following player again ");
		}
		else if (!__instance.m_follow)
		{
			__instance.SetFollowTarget(Player.m_localPlayer.gameObject);
			LogMessage("Following player again ");
		}
	}

	private static void NPCCurrentModeUpdate(ThrallAI __instance)
	{
		if (NPCCurrentMode == NPCMode.Passive)
		{
			__instance.m_aggravatable = false;
			((BaseAI)__instance).m_alerted = false;
			((BaseAI)__instance).m_aggravated = false;
			__instance.m_targetCreature = null;
			__instance.SetHuntPlayer(hunt: false);
			__instance.m_viewRange = 0f;
		}
		else if (NPCCurrentMode == NPCMode.Defensive)
		{
			if (NPCCurrentCommandType == NPCCommand.CommandType.CombatAttack)
			{
				((BaseAI)__instance).m_alerted = false;
				__instance.m_aggravatable = true;
				__instance.SetHuntPlayer(hunt: true);
				__instance.m_viewRange = 80f;
			}
		}
		else if (NPCCurrentMode == NPCMode.Aggressive)
		{
			SetMonsterAIAggravated(__instance, Aggravated: true);
			((BaseAI)__instance).m_aggravated = true;
			__instance.SetAlerted(alert: true);
			__instance.SetHuntPlayer(hunt: true);
			__instance.m_viewRange = 80f;
		}
	}

	[HarmonyPrefix]
	[HarmonyPatch(typeof(ThrallAI), "UpdateAI")]
	private static bool MonsterAI_UpdateAI_Prefix(ThrallAI __instance)
	{
		if (!Player.m_localPlayer || !__instance)
		{
			return true;
		}
		if (!__instance.name.Contains("HumanoidNPC"))
		{
			return true;
		}
		HumanoidNPC component = __instance.gameObject.GetComponent<HumanoidNPC>();
		if (NPCCurrentMode != NPCMode.Passive && enemyList.Count > 0 && HandleEnemies(__instance))
		{
			return true;
		}
		PreProcessCommand();
		if (NPCCurrentCommandType == NPCCommand.CommandType.PatrolArea && patrol_position != Vector3.zero)
		{
			return ProcessPatrolCommand(__instance, component);
		}
		if (NPCCurrentCommandType == NPCCommand.CommandType.HarvestResource && enemyList.Count == 0)
		{
			ProcessHarvestCommand(__instance, component);
		}
		if (NPCCurrentCommandType == NPCCommand.CommandType.CombatAttack)
		{
			ProcessCombatCommand(__instance);
		}
		if (NPCCurrentCommandType == NPCCommand.CommandType.FollowPlayer)
		{
			ProcessFollowCommand(__instance);
		}
		NPCCurrentModeUpdate(__instance);
		return true;
	}

	[HarmonyPostfix]
	[HarmonyPatch(typeof(HumanoidNPC), "CustomFixedUpdate")]
	private static void HumanoidNPC_CustomFixedUpdate_Postfix(HumanoidNPC __instance)
	{
		ThrallAI component = __instance.GetComponent<ThrallAI>();
		if (!component)
		{
			return;
		}
		if (NPCCurrentCommandType == NPCCommand.CommandType.FollowPlayer && (Player.m_localPlayer == null || component.m_follow == null))
		{
			component.SetFollowTarget(null);
			return;
		}
		if (__instance.LastPosition.DistanceTo(__instance.transform.position) > 1.5f || ((Character)__instance).m_lastHit != NPCLastHitData)
		{
			NPCLastHitData = ((Character)__instance).m_lastHit;
			__instance.LastPosition = __instance.transform.position;
			__instance.LastMovedAtTime = Time.time;
		}
		GameObject follow = component.m_follow;
		Character character = null;
		if ((bool)follow)
		{
			character = follow.gameObject.GetComponent<Character>();
		}
		if (((bool)component.m_targetCreature && IsRangedWeapon(__instance.GetCurrentWeapon()) && CheckArrows(((Humanoid)__instance).m_inventory) > 0) || !(follow != null) || !(follow != Player.m_localPlayer.gameObject))
		{
			return;
		}
		if (useWeapon != null && !__instance.IsItemEquiped(useWeapon))
		{
			__instance.EquipItem(useWeapon);
		}
		float num = follow.transform.position.DistanceTo(__instance.transform.position);
		if ((NPCCurrentCommandType == NPCCommand.CommandType.HarvestResource && ExposedGameObjectExtension.HasAnyComponent(follow, new string[5] { "Destructible", "TreeBase", "TreeLog", "MineRock", "MineRock5" }) && Time.time - NewFollowTargetLastRefresh > MaxChaseTimeForOneFollowTarget && NewFollowTargetLastRefresh != 0f) || (Time.time - __instance.LastMovedAtTime > MaxChaseTimeForOneFollowTarget && num < 8f))
		{
			LogMessage("NPC seems to be stuck for >20s while trying to harvest " + follow.gameObject.name + ", evading task!");
			blacklistedItems.Add(follow.gameObject);
			__instance.LastMovedAtTime = Time.time;
			RefreshAllGameObjectInstances();
			component.SetFollowTarget(null);
		}
		else
		{
			if (__instance.InAttack())
			{
				return;
			}
			float num2 = 0.8f;
			if (ExposedGameObjectExtension.HasAnyComponent(follow, new string[2] { "ItemDrop", "Pickable" }))
			{
				num2 = 2f;
			}
			else if (ExposedGameObjectExtension.HasAnyComponent(follow, new string[1] { "TreeLog" }))
			{
				num2 = 1f;
			}
			else if (ExposedGameObjectExtension.HasAnyComponent(follow, new string[1] { "TreeBase" }))
			{
				num2 = 1.25f;
			}
			if (num < FollowUntilDistance + num2 + 6f && NewFollowTargetLastRefresh == 0f)
			{
				NewFollowTargetLastRefresh = Time.time;
			}
			if (num < FollowUntilDistance + num2)
			{
				if (ExposedGameObjectExtension.HasAnyComponent(follow, new string[1] { "ItemDrop" }))
				{
					instance.PickupItemDrop(__instance, component);
					if (!follow)
					{
						ItemDrop itemDrop = SphereSearchForGameObjectWithComponent<ItemDrop>(component.transform.position, 8f);
						if (itemDrop != null)
						{
							LogInfo("Found another nearby item drop " + itemDrop.name);
							component.SetFollowTarget(itemDrop.gameObject);
						}
						else
						{
							component.SetFollowTarget(null);
						}
					}
				}
				else if (ExposedGameObjectExtension.HasAnyComponent(follow, new string[1] { "Pickable" }))
				{
					__instance.O_DoInteractAnimation(follow.transform.position);
					Pickable component2 = follow.GetComponent<Pickable>();
					component2.Interact(Player.m_localPlayer, repeat: false, alt: false);
					UnityEngine.Object.Destroy(follow);
					ItemDrop itemDrop2 = SphereSearchForGameObjectWithComponent<ItemDrop>(component.transform.position, 8f);
					if (itemDrop2 != null)
					{
						component.SetFollowTarget(itemDrop2.gameObject);
						LogInfo("Found nearby item drop " + itemDrop2.name + " after interacting with pickable");
					}
					else
					{
						component.SetFollowTarget(null);
						LogInfo("follow target set to null after interacting with pickable");
					}
				}
				else if (follow != Player.m_localPlayer.gameObject && !HasAnyChildComponent(follow, new List<Type> { typeof(Character) }))
				{
					bool charge = false;
					string text = follow.name.ToLower();
					if ((text.Contains("log") && text.Contains("half")) || (text.Contains("log") && __instance.transform.position.z - follow.transform.position.z > -5f))
					{
						charge = true;
					}
					else if (follow.name.ToLower().Contains("log"))
					{
						charge = UnityEngine.Random.value > 0.25f;
					}
					((BaseAI)component).LookAt(follow.transform.position);
					__instance.StartAttack(character ? character : __instance, charge);
					LogError("Attacking resource " + text);
				}
			}
			else if (__instance.GetVelocity().magnitude < 0.2f && Time.time - __instance.LastMovedAtTime > 3f && !((BaseAI)component).CanMove(__instance.transform.position - follow.transform.position, 1f, 1f))
			{
				((BaseAI)component).LookAt(follow.transform.position);
				__instance.StartAttack(character ? character : __instance, UnityEngine.Random.value > 0.5f);
			}
		}
	}

	[HarmonyPostfix]
	[HarmonyPatch(typeof(ThrallAI), "SetFollowTarget")]
	private static void MonsterAI_SetFollowTarget_Postfix(ThrallAI __instance)
	{
		if (!IsStringEqual(__instance.name, NPCPrefabName))
		{
			return;
		}
		NewFollowTargetLastRefresh = 0f;
		useWeapon = null;
		if (__instance.m_follow == null)
		{
			targetDamageModifiers = default(HitData.DamageModifiers);
			return;
		}
		GameObject gameObject = __instance.m_follow.gameObject;
		if (ExposedGameObjectExtension.HasAnyComponent(gameObject, new string[1] { "TreeLog" }))
		{
			TreeLog component = gameObject.GetComponent<TreeLog>();
			targetDamageModifiers = component.m_damages;
		}
		else if (ExposedGameObjectExtension.HasAnyComponent(gameObject, new string[1] { "TreeBase" }))
		{
			TreeBase component2 = gameObject.GetComponent<TreeBase>();
			targetDamageModifiers = component2.m_damageModifiers;
		}
		else if (ExposedGameObjectExtension.HasAnyComponent(gameObject, new string[2] { "Character", "Humanoid" }))
		{
			Character component3 = gameObject.GetComponent<Character>();
			if ((bool)component3)
			{
				targetDamageModifiers = component3.m_damageModifiers;
			}
			else
			{
				Humanoid component4 = gameObject.GetComponent<Humanoid>();
				if ((bool)component4)
				{
					targetDamageModifiers = component4.m_damageModifiers;
				}
			}
		}
		else if (ExposedGameObjectExtension.HasAnyComponent(gameObject, new string[1] { "MineRock" }))
		{
			MineRock component5 = gameObject.GetComponent<MineRock>();
			targetDamageModifiers = component5.m_damageModifiers;
		}
		else if (ExposedGameObjectExtension.HasAnyComponent(gameObject, new string[1] { "MineRock5" }))
		{
			MineRock5 component6 = gameObject.GetComponent<MineRock5>();
			targetDamageModifiers = component6.m_damageModifiers;
		}
		else
		{
			if (!ExposedGameObjectExtension.HasAnyComponent(gameObject, new string[1] { "Destructible" }))
			{
				targetDamageModifiers = default(HitData.DamageModifiers);
				return;
			}
			Destructible component7 = gameObject.GetComponent<Destructible>();
			targetDamageModifiers = component7.m_damages;
		}
		if ((bool)humanoid_PlayerNPC)
		{
			ItemDrop.ItemData bestHarvestingTool = GetBestHarvestingTool(((Humanoid)humanoid_PlayerNPC).m_inventory.m_inventory, targetDamageModifiers);
			if (bestHarvestingTool != null)
			{
				LogInfo("Equipping best weapon: " + bestHarvestingTool.m_shared.m_name + " for " + CleanKey(gameObject.name));
				useWeapon = bestHarvestingTool;
				humanoid_PlayerNPC.EquipItem(bestHarvestingTool);
			}
		}
	}

	[HarmonyPrefix]
	[HarmonyPatch(typeof(Humanoid), "StartAttack")]
	private static bool Humanoid_StartAttack_Prefix(Humanoid __instance, Character target, bool secondaryAttack, bool __result)
	{
		if (!IsStringEqual(NPCPrefabName, __instance.name))
		{
			return true;
		}
		lastAttackedObjectZDOID = target.GetZDOID().ToString();
		if ((__instance.InAttack() && !__instance.HaveQueuedChain()) || __instance.InDodge() || !__instance.CanMove() || __instance.IsKnockedBack() || __instance.IsStaggering() || __instance.InMinorAction())
		{
			__result = false;
			return false;
		}
		ItemDrop.ItemData currentWeapon = __instance.GetCurrentWeapon();
		if (currentWeapon == null)
		{
			__result = false;
			return false;
		}
		if (secondaryAttack && !currentWeapon.HaveSecondaryAttack())
		{
			__result = false;
			return false;
		}
		if (!secondaryAttack && !currentWeapon.HavePrimaryAttack())
		{
			__result = false;
			return false;
		}
		if (__instance.m_currentAttack != null)
		{
			__instance.m_currentAttack.Stop();
			__instance.m_previousAttack = __instance.m_currentAttack;
			__instance.m_currentAttack = null;
		}
		Attack attack = (secondaryAttack ? (attack = currentWeapon.m_shared.m_secondaryAttack.Clone()) : (attack = currentWeapon.m_shared.m_attack.Clone()));
		if (attack.Start(__instance, ((Character)__instance).m_body, ((Character)__instance).m_zanim, ((Character)__instance).m_animEvent, __instance.m_visEquipment, currentWeapon, __instance.m_previousAttack, __instance.m_timeSinceLastAttack, 1f))
		{
			__instance.ClearActionQueue();
			__instance.StartAttackGroundCheck();
			__instance.m_currentAttack = attack;
			__instance.m_currentAttackIsSecondary = secondaryAttack;
			__instance.m_lastCombatTimer = 0f;
			__result = true;
		}
		__result = false;
		return false;
	}

	[HarmonyPrefix]
	[HarmonyPatch(typeof(BaseAI), "Follow")]
	private static bool BaseAI_Follow_Prefix(BaseAI __instance, GameObject go, float dt)
	{
		if (!Player.m_localPlayer)
		{
			return true;
		}
		if (!__instance.name.Contains(NPCPrefabName))
		{
			return true;
		}
		float num;
		float num2;
		if (go == Player.m_localPlayer.gameObject)
		{
			num = 10f;
			num2 = 7f;
		}
		else
		{
			num = RunUntilDistance;
			num2 = FollowUntilDistance;
		}
		float num3 = Vector3.Distance(go.transform.position, __instance.transform.position);
		bool flag = num3 > num;
		if (NPCCurrentCommandType == NPCCommand.CommandType.FollowPlayer)
		{
			flag = flag && !Player.m_localPlayer.IsCrouching() && !((Character)Player.m_localPlayer).m_walk;
		}
		if (NPCCurrentCommandType == NPCCommand.CommandType.CombatSneakAttack)
		{
			flag = false;
		}
		if (num3 < num2 - (Player.m_localPlayer.IsCrouching() ? 5f : 2f))
		{
			__instance.StopMoving();
		}
		else
		{
			__instance.MoveTo(dt, go.transform.position, 0f, flag);
		}
		return false;
	}

	[HarmonyPrefix]
	[HarmonyPatch(typeof(Character), "GetHoverText")]
	private static bool Character_GetHoverText_Prefix(Character __instance, ref string __result)
	{
		if (__instance.name.Contains("HumanoidNPC"))
		{
			HumanoidNPC component = __instance.GetComponent<HumanoidNPC>();
			__result = __instance.m_name;
			__result = __result + "\n<color=yellow><b>[" + instance.inventoryKey.Value.ToString() + "]</b></color> Inventory";
			__result = __result + "\n<color=yellow><b>[" + instance.talkKey.Value.ToString() + "]</b></color> Push to Talk";
			__result = __result + "\n<color=yellow><b>[" + instance.thrallMenuKey.Value.ToString() + "]</b></color> Menu";
			__result += $"\n<color=yellow><b>[{instance.combatModeKey.Value.ToString()}]</b></color> Combat Mode: <color=yellow>{NPCCurrentMode}</color>";
			return false;
		}
		return true;
	}

	private void PickupItemDrop(HumanoidNPC __instance, ThrallAI thrallAIcomp)
	{
		__instance.O_DoInteractAnimation(thrallAIcomp.m_follow.transform.position);
		ItemDrop component = thrallAIcomp.m_follow.GetComponent<ItemDrop>();
		FloatingTerrainDummy floatingTerrainDummy = null;
		if (component == null || __instance.HaveUniqueKey(component.m_itemData.m_shared.m_name) || !component.GetComponent<ZNetView>().IsValid())
		{
			return;
		}
		if (!component.CanPickup())
		{
			component.RequestOwn();
		}
		else
		{
			if (component.InTar())
			{
				return;
			}
			component.Load();
			string name = component.name;
			LogMessage(__instance.m_name + " is picking up " + component.name);
			if (component == null || component.m_itemData.m_shared.m_icons == null || component.m_itemData.m_shared.m_icons.Length == 0 || component.m_itemData.m_variant >= component.m_itemData.m_shared.m_icons.Length || !component.CanPickup() || ((Humanoid)__instance).m_inventory.ContainsItem(component.m_itemData))
			{
				return;
			}
			if (component.m_itemData.m_shared.m_questItem && __instance.HaveUniqueKey(component.m_itemData.m_shared.m_name))
			{
				LogInfo("Thrall cannot pickup item " + component.GetHoverName() + " " + component.name);
				return;
			}
			int stack = component.m_itemData.m_stack;
			bool flag = ((Humanoid)__instance).m_inventory.AddItem(component.m_itemData);
			if (((Character)__instance).m_nview.GetZDO() == null)
			{
				UnityEngine.Object.Destroy(component.gameObject);
				return;
			}
			if (!flag)
			{
				LogInfo("Thrall can't pickup item " + component.GetHoverName() + " " + component.name + " because no room");
				return;
			}
			if (NPCCurrentCommandType == NPCCommand.CommandType.HarvestResource && IsStringEqual(CurrentHarvestResourceName, name))
			{
				if (NPCCurrentCommand != null && NPCCurrentCommand is HarvestAction)
				{
					HarvestAction harvestAction = (HarvestAction)NPCCurrentCommand;
					harvestAction.RequiredAmount = Math.Max(harvestAction.RequiredAmount - stack, 0);
				}
				else
				{
					LogInfo("NPC picked up CurrentHarvestResource " + name + " but currentcommand is null or not a HarvestAction");
				}
			}
			if (component.m_itemData.m_shared.m_questItem)
			{
				__instance.AddUniqueKey(component.m_itemData.m_shared.m_name);
			}
			ZNetScene.instance.Destroy(component.gameObject);
			if (flag && component.m_itemData.IsWeapon() && ((Humanoid)__instance).m_rightItem == null && ((Humanoid)__instance).m_hiddenRightItem == null && (((Humanoid)__instance).m_leftItem == null || !((Humanoid)__instance).m_leftItem.IsTwoHanded()) && (((Humanoid)__instance).m_hiddenLeftItem == null || !((Humanoid)__instance).m_hiddenLeftItem.IsTwoHanded()))
			{
				__instance.EquipItem(component.m_itemData);
			}
			__instance.m_pickupEffects.Create(__instance.transform.position, Quaternion.identity);
		}
	}

	[HarmonyPrefix]
	[HarmonyPatch(typeof(Humanoid), "EquipBestWeapon")]
	private static bool Humanoid_EquipBestWeapon_Prefix(Humanoid __instance, Character targetCreature, StaticTarget targetStatic, Character hurtFriend, Character friend)
	{
		List<ItemDrop.ItemData> allItems = __instance.m_inventory.GetAllItems();
		if (allItems.Count == 0 || __instance.InAttack())
		{
			return false;
		}
		float num = 0f;
		if ((bool)targetCreature)
		{
			float radius = targetCreature.GetRadius();
			num = Vector3.Distance(targetCreature.transform.position, __instance.transform.position) - radius;
		}
		else if ((bool)targetStatic)
		{
			num = Vector3.Distance(targetStatic.transform.position, __instance.transform.position);
		}
		float time = Time.time;
		__instance.IsFlying();
		__instance.IsSwimming();
		Humanoid.optimalWeapons.Clear();
		Humanoid.outofRangeWeapons.Clear();
		Humanoid.allWeapons.Clear();
		foreach (ItemDrop.ItemData item in allItems)
		{
			if (!item.IsWeapon() || !((Character)__instance).m_baseAI.CanUseAttack(item) || (IsRangedWeapon(item) && CheckArrows(__instance.m_inventory) == 0))
			{
				continue;
			}
			if (item.m_shared.m_aiTargetType == ItemDrop.ItemData.AiTarget.Enemy)
			{
				if (num < item.m_shared.m_aiAttackRangeMin)
				{
					continue;
				}
				Humanoid.allWeapons.Add(item);
				if ((targetCreature == null && targetStatic == null) || time - item.m_lastAttackTime < item.m_shared.m_aiAttackInterval)
				{
					continue;
				}
				if (num > item.m_shared.m_aiAttackRange)
				{
					Humanoid.outofRangeWeapons.Add(item);
					continue;
				}
				if (item.m_shared.m_aiPrioritized)
				{
					__instance.EquipItem(item);
					return false;
				}
				Humanoid.optimalWeapons.Add(item);
			}
			else if (item.m_shared.m_aiTargetType == ItemDrop.ItemData.AiTarget.FriendHurt)
			{
				if (!(hurtFriend == null) && !(time - item.m_lastAttackTime < item.m_shared.m_aiAttackInterval))
				{
					if (item.m_shared.m_aiPrioritized)
					{
						__instance.EquipItem(item);
						return false;
					}
					Humanoid.optimalWeapons.Add(item);
				}
			}
			else if (item.m_shared.m_aiTargetType == ItemDrop.ItemData.AiTarget.Friend && !(friend == null) && !(time - item.m_lastAttackTime < item.m_shared.m_aiAttackInterval))
			{
				if (item.m_shared.m_aiPrioritized)
				{
					__instance.EquipItem(item);
					return false;
				}
				Humanoid.optimalWeapons.Add(item);
			}
		}
		if (Humanoid.optimalWeapons.Count > 0)
		{
			foreach (ItemDrop.ItemData optimalWeapon in Humanoid.optimalWeapons)
			{
				if (optimalWeapon.m_shared.m_aiPrioritized)
				{
					__instance.EquipItem(optimalWeapon);
					return false;
				}
			}
			__instance.EquipItem(Humanoid.optimalWeapons[UnityEngine.Random.Range(0, Humanoid.optimalWeapons.Count)]);
		}
		else if (Humanoid.outofRangeWeapons.Count > 0)
		{
			foreach (ItemDrop.ItemData outofRangeWeapon in Humanoid.outofRangeWeapons)
			{
				if (outofRangeWeapon.m_shared.m_aiPrioritized)
				{
					__instance.EquipItem(outofRangeWeapon);
					return false;
				}
			}
			__instance.EquipItem(Humanoid.outofRangeWeapons[UnityEngine.Random.Range(0, Humanoid.outofRangeWeapons.Count)]);
		}
		else if (Humanoid.allWeapons.Count > 0)
		{
			foreach (ItemDrop.ItemData allWeapon in Humanoid.allWeapons)
			{
				if (allWeapon.m_shared.m_aiPrioritized)
				{
					__instance.EquipItem(allWeapon);
					return false;
				}
			}
			__instance.EquipItem(Humanoid.allWeapons[UnityEngine.Random.Range(0, Humanoid.allWeapons.Count)]);
		}
		else
		{
			ItemDrop.ItemData currentWeapon = __instance.GetCurrentWeapon();
			__instance.UnequipItem(currentWeapon, triggerEquipEffects: false);
		}
		return false;
	}

	[HarmonyPostfix]
	[HarmonyPatch(typeof(Humanoid), "EquipItem")]
	private static void HumanoidNPC_EquipItem_Postfix(Humanoid __instance, ItemDrop.ItemData item, bool triggerEquipEffects = true)
	{
		if (IsStringEqual(__instance.name, NPCPrefabName) && item.m_shared.m_skillType == Skills.SkillType.Bows && item.m_shared.m_aiAttackRange < 10f)
		{
			item.m_shared.m_aiAttackRange = 20f;
		}
	}

	[HarmonyPrefix]
	[HarmonyPatch(typeof(Humanoid), "OnDamaged")]
	public static void Character_OnDamaged_Prefix(Humanoid __instance, HitData hit)
	{
		Player localPlayerOrNull = GetLocalPlayerOrNull();
		if (NPCCurrentMode != NPCMode.Passive && (bool)PlayerNPC && (__instance == localPlayerOrNull || __instance is HumanoidNPC))
		{
			Character attacker = hit.GetAttacker();
			if (attacker != null && !enemyList.Contains(attacker) && attacker != localPlayerOrNull)
			{
				enemyList.Add(attacker);
			}
		}
	}

	[HarmonyPrefix]
	[HarmonyPatch(typeof(Character), "OnDeath")]
	private static void Character_OnDeath_Prefix(Character __instance)
	{
		if (!PlayerNPC || (NPCCurrentCommandType != NPCCommand.CommandType.CombatAttack && NPCCurrentCommandType != NPCCommand.CommandType.CombatSneakAttack))
		{
			return;
		}
		Debug.LogError("Character_OnDeath_Prefix");
		if (NPCCurrentCommand != null && NPCCurrentCommand is AttackAction)
		{
			Debug.LogError("is AttackAction");
			AttackAction attackAction = (AttackAction)NPCCurrentCommand;
			if (IsStringEqual(__instance.gameObject.name, attackAction.TargetName) && __instance.GetZDOID().ToString() == lastAttackedObjectZDOID)
			{
				Debug.LogError("target " + attackAction.TargetName + " killed ");
				attackAction.TargetQuantity = Math.Max(attackAction.TargetQuantity - 1, 0);
				LogInfo($"{attackAction.TargetQuantity} {attackAction.TargetName} remaining to kill");
			}
		}
	}

	[HarmonyPrefix]
	[HarmonyPatch(typeof(Character), "RPC_Damage")]
	private static bool Character_RPC_Damage_Prefix(Character __instance, long sender, HitData hit)
	{
		if (__instance.IsDebugFlying())
		{
			return false;
		}
		if (hit.GetAttacker() == Player.m_localPlayer)
		{
			Game.instance.IncrementPlayerStat(__instance.IsPlayer() ? PlayerStatType.PlayerHits : PlayerStatType.EnemyHits);
			__instance.m_localPlayerHasHit = true;
		}
		if (!__instance.m_nview.IsOwner() || __instance.GetHealth() <= 0f || __instance.IsDead() || __instance.IsTeleporting() || __instance.InCutscene() || (hit.m_dodgeable && __instance.IsDodgeInvincible()))
		{
			return false;
		}
		Character attacker = hit.GetAttacker();
		if ((hit.HaveAttacker() && attacker == null) || (__instance.IsPlayer() && !__instance.IsPVPEnabled() && attacker != null && attacker.IsPlayer() && !hit.m_ignorePVP))
		{
			return false;
		}
		if (attacker != null && !attacker.IsPlayer())
		{
			float difficultyDamageScalePlayer = Game.instance.GetDifficultyDamageScalePlayer(__instance.transform.position);
			hit.ApplyModifier(difficultyDamageScalePlayer);
			hit.ApplyModifier(Game.m_enemyDamageRate);
		}
		__instance.m_seman.OnDamaged(hit, attacker);
		if (__instance.m_baseAI != null && __instance.m_baseAI.IsAggravatable() && !__instance.m_baseAI.IsAggravated() && (bool)attacker && attacker.IsPlayer() && hit.GetTotalDamage() > 0f)
		{
			BaseAI.AggravateAllInArea(__instance.transform.position, 20f, BaseAI.AggravatedReason.Damage);
		}
		if (__instance.m_baseAI != null && !__instance.m_baseAI.IsAlerted() && hit.m_backstabBonus > 1f && Time.time - __instance.m_backstabTime > 300f && (!ZoneSystem.instance.GetGlobalKey(GlobalKeys.PassiveMobs) || !__instance.m_baseAI.CanSeeTarget(attacker)))
		{
			__instance.m_backstabTime = Time.time;
			hit.ApplyModifier(hit.m_backstabBonus);
			__instance.m_backstabHitEffects.Create(hit.m_point, Quaternion.identity, __instance.transform);
		}
		if (__instance.IsStaggering() && !__instance.IsPlayer())
		{
			hit.ApplyModifier(2f);
			__instance.m_critHitEffects.Create(hit.m_point, Quaternion.identity, __instance.transform);
		}
		if (hit.m_blockable && __instance.IsBlocking())
		{
			__instance.BlockAttack(hit, attacker);
		}
		__instance.ApplyPushback(hit);
		if (hit.m_statusEffectHash != 0)
		{
			StatusEffect statusEffect = __instance.m_seman.GetStatusEffect(hit.m_statusEffectHash);
			if (statusEffect == null)
			{
				statusEffect = __instance.m_seman.AddStatusEffect(hit.m_statusEffectHash, resetTime: false, hit.m_itemLevel, hit.m_skillLevel);
			}
			else
			{
				statusEffect.ResetTime();
				statusEffect.SetLevel(hit.m_itemLevel, hit.m_skillLevel);
			}
			if (statusEffect != null && attacker != null)
			{
				statusEffect.SetAttacker(attacker);
			}
		}
		WeakSpot weakSpot = __instance.GetWeakSpot(hit.m_weakSpot);
		if (weakSpot != null)
		{
			ZLog.Log("HIT Weakspot:" + weakSpot.gameObject.name);
		}
		HitData.DamageModifiers damageModifiers = __instance.GetDamageModifiers(weakSpot);
		hit.ApplyResistance(damageModifiers, out var significantModifier);
		if (__instance.IsPlayer() || __instance is HumanoidNPC)
		{
			float bodyArmor = __instance.GetBodyArmor();
			hit.ApplyArmor(bodyArmor);
			__instance.DamageArmorDurability(hit);
		}
		else if (Game.m_worldLevel > 0)
		{
			hit.ApplyArmor(Game.m_worldLevel * Game.instance.m_worldLevelEnemyBaseAC);
		}
		float poison = hit.m_damage.m_poison;
		float fire = hit.m_damage.m_fire;
		float spirit = hit.m_damage.m_spirit;
		hit.m_damage.m_poison = 0f;
		hit.m_damage.m_fire = 0f;
		hit.m_damage.m_spirit = 0f;
		__instance.ApplyDamage(hit, showDamageText: true, triggerEffects: true, significantModifier);
		__instance.AddFireDamage(fire);
		__instance.AddSpiritDamage(spirit);
		__instance.AddPoisonDamage(poison);
		__instance.AddFrostDamage(hit.m_damage.m_frost);
		__instance.AddLightningDamage(hit.m_damage.m_lightning);
		return false;
	}

	[HarmonyPrefix]
	[HarmonyPatch(typeof(Player), "UpdateFood")]
	private static bool Player_UpdateFood_Prefix(Player __instance, float dt, bool forceUpdate)
	{
		__instance.m_foodUpdateTimer += dt;
		if (__instance.m_foodUpdateTimer >= 1f || forceUpdate)
		{
			__instance.m_foodUpdateTimer -= 1f;
			foreach (Player.Food food in __instance.m_foods)
			{
				food.m_time -= 1f;
				float f = Mathf.Clamp01(food.m_time / food.m_item.m_shared.m_foodBurnTime);
				f = Mathf.Pow(f, 0.3f);
				food.m_health = food.m_item.m_shared.m_food * f;
				food.m_stamina = food.m_item.m_shared.m_foodStamina * f;
				food.m_eitr = food.m_item.m_shared.m_foodEitr * f;
				if (food.m_time <= 0f)
				{
					__instance.m_foods.Remove(food);
					break;
				}
			}
			__instance.GetTotalFoodValue(out float hp, out float stamina, out float eitr);
			__instance.SetMaxHealth(hp, flashBar: true);
			__instance.SetMaxStamina(stamina, flashBar: true);
			__instance.SetMaxEitr(eitr, flashBar: true);
			if (humanoid_PlayerNPC != null && (Math.Abs(humanoid_PlayerNPC.GetMaxHealth() - hp) > 1.5f || Math.Abs(humanoid_PlayerNPC.m_maxStamina - stamina) > 1.5f))
			{
				humanoid_PlayerNPC.SetMaxHealth(hp);
				humanoid_PlayerNPC.m_maxStamina = stamina;
				MessageHud.instance.ShowMessage(MessageHud.MessageType.TopLeft, humanoid_PlayerNPC.m_name + " stats updated:\n Max Health: " + hp.ToString("F1") + "\nMax Stamina: " + stamina.ToString("F1") + "\n\n\n", 0, (Sprite)null);
			}
			if (eitr > 0f)
			{
				__instance.ShowTutorial("eitr");
			}
		}
		if (forceUpdate)
		{
			return false;
		}
		__instance.m_foodRegenTimer += dt;
		if (!(__instance.m_foodRegenTimer >= 10f))
		{
			return false;
		}
		__instance.m_foodRegenTimer = 0f;
		float num = 0f;
		foreach (Player.Food food2 in __instance.m_foods)
		{
			num += food2.m_item.m_shared.m_foodRegen;
		}
		if (num > 0f)
		{
			float regenMultiplier = 1f;
			((Character)__instance).m_seman.ModifyHealthRegen(ref regenMultiplier);
			num *= regenMultiplier;
			__instance.Heal(num);
			if ((bool)PlayerNPC)
			{
				HumanoidNPC component = PlayerNPC.GetComponent<HumanoidNPC>();
				if (component != null)
				{
					component.Heal(num);
				}
			}
		}
		return false;
	}

	[HarmonyPostfix]
	[HarmonyPatch(typeof(Player), "SetCrouch")]
	private static void Player_SetCrouch_Postfix(Player __instance, bool crouch)
	{
		if ((bool)PlayerNPC && (bool)humanoid_PlayerNPC && NPCCurrentCommandType == NPCCommand.CommandType.FollowPlayer)
		{
			humanoid_PlayerNPC.SetCrouch(crouch);
		}
	}

	[HarmonyPostfix]
	[HarmonyPatch(typeof(Character), "SetWalk")]
	private static void Character_SetWalk_Postfix(Character __instance, bool walk)
	{
		if (__instance is Player && (bool)PlayerNPC && (bool)humanoid_PlayerNPC && NPCCurrentCommandType == NPCCommand.CommandType.FollowPlayer)
		{
			humanoid_PlayerNPC.SetWalk(walk);
		}
	}

	[HarmonyPrefix]
	[HarmonyPatch(typeof(BaseAI), "FindRandomStaticTarget")]
	private static bool BaseAI_FindRandomStaticTarget_Prefix(BaseAI __instance, float maxDistance, StaticTarget __result)
	{
		if (!IsStringEqual(__instance.name, NPCPrefabName))
		{
			return true;
		}
		__result = null;
		return false;
	}

	[HarmonyPrefix]
	[HarmonyPatch(typeof(BaseAI), "FindClosestStaticPriorityTarget")]
	private static bool BaseAI_FindClosestStaticPriorityTarget_Prefix(BaseAI __instance, StaticTarget __result)
	{
		if (!IsStringEqual(__instance.name, NPCPrefabName))
		{
			return true;
		}
		__result = null;
		return false;
	}

	[HarmonyPrefix]
	[HarmonyPatch(typeof(InventoryGui), "OnSelectedItem")]
	private static bool InventoryGui_OnSelectedItem_Prefix(InventoryGui __instance, InventoryGrid grid, ItemDrop.ItemData item, Vector2i pos, InventoryGrid.Modifier mod)
	{
		Player localPlayer = Player.m_localPlayer;
		if (localPlayer.IsTeleporting())
		{
			return false;
		}
		if ((bool)__instance.m_dragGo)
		{
			if ((bool)humanoid_PlayerNPC && __instance.m_currentContainer == humanoid_PlayerNPC.inventoryContainer && __instance.m_dragInventory != null)
			{
				if (__instance.m_dragInventory == ((Humanoid)humanoid_PlayerNPC).m_inventory && __instance.m_containerGrid != grid)
				{
					localPlayer.GetInventory().MoveItemToThis(grid.GetInventory(), __instance.m_dragItem);
					if (__instance.m_dragItem != null && __instance.m_dragItem.IsEquipable())
					{
						humanoid_PlayerNPC.UnequipItem(__instance.m_dragItem);
						if (item != null && item.IsEquipable())
						{
							humanoid_PlayerNPC.UnequipItem(item);
						}
					}
				}
				else if (__instance.m_dragInventory == ((Humanoid)localPlayer).m_inventory && __instance.m_containerGrid == grid)
				{
					__instance.m_currentContainer.GetInventory().MoveItemToThis(localPlayer.GetInventory(), __instance.m_dragItem);
					if (__instance.m_dragItem != null && __instance.m_dragItem.IsEquipable())
					{
						if (Player.m_localPlayer.IsItemEquiped(__instance.m_dragItem) || Player.m_localPlayer.GetCurrentWeapon() == __instance.m_dragItem)
						{
							Player.m_localPlayer.UnequipItem(__instance.m_dragItem);
						}
						humanoid_PlayerNPC.EquipItem(__instance.m_dragItem);
						if (item != null && item.IsEquipable())
						{
							humanoid_PlayerNPC.EquipItem(item);
						}
					}
				}
			}
			__instance.m_moveItemEffects.Create(__instance.transform.position, Quaternion.identity);
			bool flag = localPlayer.IsItemEquiped(__instance.m_dragItem);
			bool flag2 = item != null && localPlayer.IsItemEquiped(item);
			Vector2i gridPos = __instance.m_dragItem.m_gridPos;
			if ((__instance.m_dragItem.m_shared.m_questItem || (item != null && item.m_shared.m_questItem)) && __instance.m_dragInventory != grid.GetInventory())
			{
				return false;
			}
			if (!__instance.m_dragInventory.ContainsItem(__instance.m_dragItem))
			{
				__instance.SetupDragItem((ItemDrop.ItemData)null, (Inventory)null, 1);
				return false;
			}
			localPlayer.RemoveEquipAction(item);
			localPlayer.RemoveEquipAction(__instance.m_dragItem);
			localPlayer.UnequipItem(__instance.m_dragItem, triggerEquipEffects: false);
			localPlayer.UnequipItem(item, triggerEquipEffects: false);
			bool flag3 = grid.DropItem(__instance.m_dragInventory, __instance.m_dragItem, __instance.m_dragAmount, pos);
			if (__instance.m_dragItem.m_stack < __instance.m_dragAmount)
			{
				__instance.m_dragAmount = __instance.m_dragItem.m_stack;
			}
			if (flag)
			{
				ItemDrop.ItemData itemAt = grid.GetInventory().GetItemAt(pos.x, pos.y);
				if (itemAt != null)
				{
					localPlayer.EquipItem(itemAt, triggerEquipEffects: false);
				}
				if (localPlayer.GetInventory().ContainsItem(__instance.m_dragItem))
				{
					localPlayer.EquipItem(__instance.m_dragItem, triggerEquipEffects: false);
				}
			}
			if (flag2)
			{
				ItemDrop.ItemData itemAt2 = __instance.m_dragInventory.GetItemAt(gridPos.x, gridPos.y);
				if (itemAt2 != null)
				{
					localPlayer.EquipItem(itemAt2, triggerEquipEffects: false);
				}
				if (localPlayer.GetInventory().ContainsItem(item))
				{
					localPlayer.EquipItem(item, triggerEquipEffects: false);
				}
			}
			if (flag3)
			{
				__instance.SetupDragItem((ItemDrop.ItemData)null, (Inventory)null, 1);
				__instance.UpdateCraftingPanel(focusView: false);
			}
		}
		else
		{
			if (item == null)
			{
				return false;
			}
			switch (mod)
			{
			case InventoryGrid.Modifier.Move:
				if (item.m_shared.m_questItem)
				{
					return false;
				}
				if (__instance.m_currentContainer != null)
				{
					localPlayer.RemoveEquipAction(item);
					localPlayer.UnequipItem(item);
					if (grid.GetInventory() == __instance.m_currentContainer.GetInventory())
					{
						localPlayer.GetInventory().MoveItemToThis(grid.GetInventory(), item);
						if ((bool)PlayerNPC)
						{
							HumanoidNPC component = PlayerNPC.GetComponent<HumanoidNPC>();
							if (grid.GetInventory() == ((Humanoid)component).m_inventory && item.IsEquipable())
							{
								component.UnequipItem(item);
							}
						}
					}
					else
					{
						__instance.m_currentContainer.GetInventory().MoveItemToThis(localPlayer.GetInventory(), item);
						if ((bool)PlayerNPC)
						{
							HumanoidNPC component2 = PlayerNPC.GetComponent<HumanoidNPC>();
							if (__instance.m_currentContainer.GetInventory() == ((Humanoid)component2).m_inventory && item.IsEquipable())
							{
								component2.EquipItem(item);
							}
							if (item != null && localPlayer.IsItemEquiped(item))
							{
								humanoid_PlayerNPC.UnequipItem(item);
							}
						}
					}
					__instance.m_moveItemEffects.Create(__instance.transform.position, Quaternion.identity);
				}
				else if (Player.m_localPlayer.DropItem(grid.GetInventory(), item, item.m_stack))
				{
					__instance.m_moveItemEffects.Create(__instance.transform.position, Quaternion.identity);
				}
				return false;
			case InventoryGrid.Modifier.Drop:
				if (Player.m_localPlayer.DropItem(grid.GetInventory(), item, item.m_stack))
				{
					__instance.m_moveItemEffects.Create(__instance.transform.position, Quaternion.identity);
				}
				return false;
			case InventoryGrid.Modifier.Split:
				if (item.m_stack > 1)
				{
					__instance.ShowSplitDialog(item, grid.GetInventory());
					return false;
				}
				break;
			}
			__instance.SetupDragItem(item, grid.GetInventory(), item.m_stack);
		}
		return false;
	}

	private static string GetChatInputText()
	{
		if (Chat.instance != null)
		{
			return ((TMP_InputField)Chat.instance.m_input).text;
		}
		return "";
	}

	[HarmonyPrefix]
	[HarmonyPatch(typeof(Chat), "InputText")]
	private static bool Chat_InputText_Prefix(Chat __instance)
	{
		string chatInputText = GetChatInputText();
		if (IsLocalSingleplayer() && (bool)PlayerNPC && !chatInputText.StartsWith("/"))
		{
			instance.BrainSendInstruction(PlayerNPC, Voice: false);
			if ((bool)Player.m_localPlayer)
			{
				instance.AddChatTalk(Player.m_localPlayer, "NPC", chatInputText);
			}
			instance.AddChatTalk(humanoid_PlayerNPC, "NPC", "...", addToChat: false);
		}
		return false;
	}

	[HarmonyPrefix]
	[HarmonyPatch(typeof(ItemDrop), "RPC_RequestOwn")]
	private static bool ItemDrop_RPC_RequestOwn_Prefix(ItemDrop __instance, long uid)
	{
		ZLog.Log("Player " + uid + " wants to pickup " + __instance.gameObject.name + "   im: " + ZDOMan.GetSessionID());
		if (__instance.m_nview.IsOwner())
		{
			__instance.m_nview.GetZDO().SetOwner(uid);
		}
		else if (__instance.m_nview.GetZDO().GetOwner() == uid)
		{
			ZLog.Log("  but they are already the owner");
		}
		else
		{
			ZLog.Log("  but neither I nor the requesting player are the owners");
			__instance.m_nview.GetZDO().SetOwner(uid);
		}
		return false;
	}

	private static void LogInfo(string s)
	{
		logger.LogInfo((object)s);
		logEntries.Add("[Info] [" + DateTime.Now.ToString() + "] " + s);
	}

	private static void LogMessage(string s)
	{
		logger.LogMessage((object)s);
		logEntries.Add("[Message] [" + DateTime.Now.ToString() + "] " + s);
	}

	private static void LogWarning(string s)
	{
		logger.LogWarning((object)s);
		logEntries.Add("[Warning] [" + DateTime.Now.ToString() + "] " + s);
	}

	private static void LogError(string s)
	{
		logger.LogError((object)s);
		logEntries.Add("[Error] [" + DateTime.Now.ToString() + "] " + s);
	}

	private void CaptureLog(string logString, string stackTrace, LogType type)
	{
		string text = $"[{Time.time}] [{type}] {logString}";
		if (type == LogType.Exception)
		{
			text = text + "\n" + stackTrace;
		}
		logEntries.Add(text);
		if (logEntries.Count > 10000)
		{
			logEntries.RemoveAt(0);
		}
	}

	private void RestartSendLogTimer()
	{
		instance.SetTimer(30f, delegate
		{
			instance.SendLogToBrain();
			instance.RestartSendLogTimer();
		});
	}

	[HarmonyPostfix]
	[HarmonyPriority(200)]
	[HarmonyPatch(typeof(Player), "Awake")]
	public static void Player_Awake_Postfix(Player __instance)
	{
		if (__instance == null || ZNetScene.instance == null)
		{
			return;
		}
		if (!ModInitComplete)
		{
			instance.DoModInit();
		}
		else
		{
			LogInfo("Skipping Thrall mod init because it is already initialized.");
		}
		FindPlayerNPC();
		if ((bool)PlayerNPC)
		{
			return;
		}
		instance.SetTimer(1f, delegate
		{
			if (!PlayerNPC)
			{
				LogWarning("Spawning a Thrall into the world!");
				instance.SpawnCompanion();
				if ((bool)humanoid_PlayerNPC)
				{
					string text = "Hey there, I'm " + ((humanoid_PlayerNPC.m_name != "") ? humanoid_PlayerNPC.m_name : "your Thrall") + ". Press and hold T to talk with me.";
					instance.AddChatTalk(humanoid_PlayerNPC, "NPC", text);
					instance.BrainSynthesizeAudio(text, npcVoices[instance.npcVoice].ToLower());
				}
			}
		});
	}

	[HarmonyPostfix]
	[HarmonyPatch(typeof(Player), "Update")]
	private static void Player_Update_Postfix(Player __instance)
	{
		if (!FindPlayerNPCTimer)
		{
			instance.SetTimer(0.5f, delegate
			{
				FindPlayerNPC();
				FindPlayerNPCTimer = false;
			});
			FindPlayerNPCTimer = true;
		}
		if ((EventSystem.current.currentSelectedGameObject != null && (bool)EventSystem.current.currentSelectedGameObject.GetComponent<InputField>()) || !ZNetScene.instance || !Player.m_localPlayer || Player.m_localPlayer.IsTeleporting())
		{
			return;
		}
		if ((bool)humanoid_PlayerNPC)
		{
			List<Minimap.PinData> list = new List<Minimap.PinData>();
			foreach (Minimap.PinData pin in Minimap.instance.m_pins)
			{
				if (pin.m_author == "NPC" && humanoid_PlayerNPC.npcPinData != null && pin != humanoid_PlayerNPC.npcPinData)
				{
					list.Add(pin);
				}
			}
			foreach (Minimap.PinData item in list)
			{
				Minimap.instance.RemovePin(item);
			}
		}
		if (IsInventoryShowing && (ZInput.GetKeyDown(KeyCode.Escape) || ZInput.GetKeyDown(instance.inventoryKey.Value)))
		{
			SaveNPCData(PlayerNPC);
			IsInventoryShowing = false;
		}
		else if (IsModMenuShowing && ZInput.GetKeyDown(KeyCode.Escape))
		{
			instance.ToggleModMenu();
		}
		else if (ZInput.GetKeyDown(instance.inventoryKey.Value) && __instance.m_hovering == PlayerNPC && PlayerNPC != null)
		{
			IsInventoryShowing = InventoryGui.instance.m_animator.GetBool("visible");
			SaveNPCData(PlayerNPC);
		}
		else
		{
			if (Console.IsVisible())
			{
				return;
			}
			if (IsModMenuShowing && ZInput.GetKeyDown(instance.thrallMenuKey.Value))
			{
				instance.ToggleModMenu();
			}
			else
			{
				if (Menu.IsVisible() || Chat.instance.HasFocus() || !((Character)__instance).TakeInput())
				{
					return;
				}
				if (ZInput.GetKeyDown(instance.thrallMenuKey.Value))
				{
					instance.ToggleModMenu();
					return;
				}
				if (ZInput.GetKeyDown(instance.spawnKey.Value))
				{
					FindPlayerNPC();
					if ((bool)PlayerNPC)
					{
						SaveNPCData(PlayerNPC);
						((Character)humanoid_PlayerNPC).AddPoisonDamage(100000f);
						humanoid_PlayerNPC.m_health = 0f;
						MessageHud.instance.ShowMessage(MessageHud.MessageType.Center, "Thrall left the world!", 0, (Sprite)null);
					}
					else
					{
						instance.SpawnCompanion();
					}
					return;
				}
				if (ZInput.GetKeyDown(instance.followKey.Value) && (bool)PlayerNPC)
				{
					HumanoidNPC component = PlayerNPC.GetComponent<HumanoidNPC>();
					if (NPCCurrentCommandType != NPCCommand.CommandType.FollowPlayer)
					{
						MessageHud.instance.ShowMessage(MessageHud.MessageType.Center, component.m_name + " now following you!", 0, (Sprite)null);
						instance.Follow_Start(__instance.gameObject);
					}
					else
					{
						MessageHud.instance.ShowMessage(MessageHud.MessageType.Center, component.m_name + " now patrolling this area!", 0, (Sprite)null);
						instance.Patrol_Start();
					}
					return;
				}
				if (ZInput.GetKeyDown(instance.harvestKey.Value) && (bool)PlayerNPC)
				{
					HumanoidNPC component2 = PlayerNPC.GetComponent<HumanoidNPC>();
					if (NPCCurrentCommandType == NPCCommand.CommandType.HarvestResource)
					{
						instance.commandManager.RemoveCommandsOfType<HarvestAction>();
						MessageHud.instance.ShowMessage(MessageHud.MessageType.Center, component2.m_name + " stopped harvesting!", 0, (Sprite)null);
						return;
					}
					HarvestAction harvestAction = new HarvestAction();
					harvestAction.humanoidNPC = component2;
					harvestAction.ResourceName = "Wood";
					harvestAction.RequiredAmount = 20;
					harvestAction.OriginalRequiredAmount = 20;
					instance.commandManager.AddCommand(harvestAction);
					MessageHud.instance.ShowMessage(MessageHud.MessageType.Center, component2.m_name + " harvesting " + harvestAction.ResourceName.ToLower() + "!", 0, (Sprite)null);
					return;
				}
				if (ZInput.GetKeyDown(instance.combatModeKey.Value) && (bool)PlayerNPC)
				{
					HumanoidNPC component3 = PlayerNPC.GetComponent<HumanoidNPC>();
					ToggleNPCCurrentCommandType();
					MessageHud.instance.ShowMessage(MessageHud.MessageType.Center, component3.m_name + " is now " + NPCCurrentMode, 0, (Sprite)null);
				}
				if (ZInput.GetKey(instance.talkKey.Value) && !IsRecording)
				{
					instance.StartRecording();
				}
				else if (!ZInput.GetKey(instance.talkKey.Value) && IsRecording)
				{
					if (Time.time - recordingStartedTime > 1f)
					{
						shortRecordingWarningShown = false;
						instance.StopRecording();
						instance.SendRecordingToBrain();
					}
					else if (!shortRecordingWarningShown)
					{
						shortRecordingWarningShown = true;
					}
				}
				else
				{
					if (!ZInput.GetKeyDown(KeyCode.P))
					{
						return;
					}
					string currentHarvestResourceName = CurrentHarvestResourceName;
					List<(string, string, float, float, int)> source = instance.FindResourceSourcesRecursive(currentHarvestResourceName, __instance.GetCurrentWeapon());
					source = source.OrderByDescending<(string, string, float, float, int), float>(((string Category, string Name, float Efficiency, float Distance, int Depth) s) => s.Efficiency).ToList();
					if (source.Count == 0)
					{
						Debug.Log("No sources found for " + currentHarvestResourceName + " in nearby resources.");
						return;
					}
					Debug.Log("Sources for " + currentHarvestResourceName + ", sorted by efficiency:");
					for (int num = 0; num < source.Count; num++)
					{
						var (text, text2, num2, num3, num4) = source[num];
						if (num2 > 0f)
						{
							Debug.Log($"{num + 1}. {text} - {text2} (Efficiency: {num2:F2}, Distance: {num3:F2}, Depth: {num4})");
						}
						else
						{
							Debug.Log($"{num + 1}. {text} - {text2} (Not interactable with current weapon, Distance: {num3:F2}, Depth: {num4})");
						}
					}
				}
			}
		}
	}

	private void OnInventoryKeyPressed(Player player, bool Show)
	{
		if ((bool)PlayerNPC)
		{
			SaveNPCData(PlayerNPC);
			if (!Show)
			{
				InventoryGui.instance.Hide();
				IsInventoryShowing = false;
			}
			else
			{
				HumanoidNPC component = PlayerNPC.GetComponent<HumanoidNPC>();
				InventoryGui.instance.Show(component.inventoryContainer);
				IsInventoryShowing = true;
			}
		}
		else
		{
			LogError("OnInventoryKeyPressed PlayerNPC is null ");
		}
	}

	private void SpawnCompanion()
	{
		FindPlayerNPC();
		if ((bool)PlayerNPC)
		{
			LogError("Spawning more than one NPC is disabled");
			return;
		}
		Player localPlayer = Player.m_localPlayer;
		GameObject prefab = ZNetScene.instance.GetPrefab("HumanoidNPC");
		instance.commandManager.RemoveAllCommands();
		enemyList.Clear();
		if (prefab == null)
		{
			LogError("ScriptNPC prefab not found!");
		}
		Vector3 position = localPlayer.transform.position + localPlayer.transform.forward * 2f;
		Quaternion rotation = localPlayer.transform.rotation;
		GameObject gameObject = UnityEngine.Object.Instantiate(prefab, position, rotation);
		gameObject.SetActive(value: true);
		CapsuleCollider component = gameObject.GetComponent<CapsuleCollider>();
		component.radius = 0.7f;
		VisEquipment component2 = gameObject.GetComponent<VisEquipment>();
		VisEquipment component3 = localPlayer.GetComponent<VisEquipment>();
		component2.m_isPlayer = true;
		component2.m_emptyBodyTexture = component3.m_emptyBodyTexture;
		component2.m_emptyLegsTexture = component3.m_emptyLegsTexture;
		PlayerNPC = gameObject;
		if (ExposedGameObjectExtension.HasAnyComponent(gameObject, new string[1] { "Tameable" }))
		{
			UnityEngine.Object.Destroy(gameObject.GetComponent<Tameable>());
		}
		ThrallAI component4 = gameObject.GetComponent<ThrallAI>();
		SetMonsterAIAggravated(component4, Aggravated: false);
		component4.MakeTame();
		component4.SetFollowTarget(localPlayer.gameObject);
		component4.m_viewRange = 80f;
		component4.m_alertRange = 800f;
		component4.m_maxChaseDistance = 500f;
		component4.m_fleeIfLowHealth = 0f;
		component4.m_fleeIfNotAlerted = false;
		component4.m_fleeIfHurtWhenTargetCantBeReached = false;
		component4.m_aggravatable = false;
		((BaseAI)component4).m_alerted = false;
		((BaseAI)component4).m_aggravated = false;
		component4.m_targetCreature = null;
		component4.SetHuntPlayer(hunt: false);
		component4.m_viewRange = 0f;
		NPCCurrentMode = NPCMode.Defensive;
		HumanoidNPC humanoidNPC = (humanoid_PlayerNPC = gameObject.GetComponent<HumanoidNPC>());
		if (humanoidNPC != null)
		{
			LoadNPCData(humanoidNPC);
			EquipBestClothes(humanoidNPC);
			MessageHud.instance.ShowMessage(MessageHud.MessageType.Center, humanoidNPC.m_name + " has entered the world!", 0, (Sprite)null);
			Character character = humanoidNPC;
			character.m_onDeath = (Action)Delegate.Combine(character.m_onDeath, new Action(OnNPCDeath));
			if (((Humanoid)humanoidNPC).m_inventory.m_inventory.Count == 0)
			{
				GameObject prefab2 = ZNetScene.instance.GetPrefab("ArmorRagsChest");
				ItemDrop.ItemData item = humanoidNPC.PickupPrefab(prefab2, 1);
				humanoidNPC.EquipItem(item);
				prefab2 = ZNetScene.instance.GetPrefab("ArmorRagsLegs");
				item = humanoidNPC.PickupPrefab(prefab2, 1);
				humanoidNPC.EquipItem(item);
				LogInfo("Thrall's inventory size was 0, giving default rags");
			}
			humanoidNPC.m_walkSpeed = localPlayer.m_walkSpeed;
			humanoidNPC.m_runSpeed = localPlayer.m_runSpeed;
			humanoidNPC.SetHair("Hair17");
			humanoidNPC.SetMaxHealth(300f);
			humanoidNPC.SetHealth(300f);
			humanoidNPC.inventoryContainer = gameObject.AddComponent<Container>();
			humanoidNPC.inventoryContainer.m_inventory = ((Humanoid)humanoidNPC).m_inventory;
		}
		else
		{
			LogError("humanoidNpc_Component component not found on the instantiated ScriptNPC prefab!");
		}
	}

	protected virtual void OnNPCDeath()
	{
		MessageHud.instance.ShowMessage(MessageHud.MessageType.Center, "Your Thrall died! Press [G] to respawn", 0, (Sprite)null);
		HumanoidNPC component = PlayerNPC.GetComponent<HumanoidNPC>();
		SaveNPCData(PlayerNPC);
	}

	[HarmonyPrefix]
	[HarmonyPatch(typeof(ZNetScene), "RemoveObjects")]
	private static bool ZNetScene_RemoveObjects_Prefix(ZNetScene __instance, List<ZDO> currentNearObjects, List<ZDO> currentDistantObjects)
	{
		byte b = (byte)(Time.frameCount & 0xFF);
		foreach (ZDO currentNearObject in currentNearObjects)
		{
			currentNearObject.TempRemoveEarmark = b;
		}
		foreach (ZDO currentDistantObject in currentDistantObjects)
		{
			currentDistantObject.TempRemoveEarmark = b;
		}
		__instance.m_tempRemoved.Clear();
		foreach (ZNetView value in __instance.m_instances.Values)
		{
			if ((bool)value && value.GetZDO() != null && value.GetZDO().TempRemoveEarmark != b)
			{
				__instance.m_tempRemoved.Add(value);
			}
		}
		for (int i = 0; i < __instance.m_tempRemoved.Count; i++)
		{
			ZNetView zNetView = __instance.m_tempRemoved[i];
			ZDO zDO = zNetView.GetZDO();
			zNetView.ResetZDO();
			UnityEngine.Object.Destroy(zNetView.gameObject);
			if (!zDO.Persistent && zDO.IsOwner())
			{
				ZDOMan.instance.DestroyZDO(zDO);
			}
			__instance.m_instances.Remove(zDO);
		}
		return false;
	}

	[HarmonyPrefix]
	[HarmonyPatch(typeof(Game), "UpdateSaving")]
	private static bool Game_UpdateSaving_Prefix()
	{
		if (instance.DisableAutoSave == null)
		{
			return false;
		}
		return !instance.DisableAutoSave.Value;
	}

	private void ToggleModMenu()
	{
		if (!PlayerNPC)
		{
			MessageHud.instance.ShowMessage(MessageHud.MessageType.Center, "Cannot open Thrall Menu without a Thrall in the world!", 0, (Sprite)null);
			return;
		}
		instance.panelManager.TogglePanel("Settings");
		instance.panelManager.TogglePanel("Thrall Customization");
		if ((bool)PlayerNPC)
		{
			SaveNPCData(PlayerNPC);
		}
	}

	private void CreateModMenuUI()
	{
		float y = 375f;
		settingsPanel = panelManager.CreatePanel("Settings", new Vector2(0f, 0.5f), new Vector2(0f, 0.5f), new Vector2(100f, y), 480f, 760f, draggable: false, new Vector2(0f, 1f));
		thrallCustomizationPanel = panelManager.CreatePanel("Thrall Customization", new Vector2(1f, 0.5f), new Vector2(1f, 0.5f), new Vector2(-100f, y), 450f, 880f, draggable: false, new Vector2(1f, 1f));
		taskQueueSubPanel = panelManager.CreateSubPanel(settingsPanel, "Task Queue", new Vector2(0.5f, 1f), new Vector2(0.5f, 1f), new Vector2(0f, -100f), 430f, 180f, new Vector2(0.5f, 1f));
		keybindsSubPanel = panelManager.CreateSubPanel(settingsPanel, "Keybinds", new Vector2(0.5f, 1f), new Vector2(0.5f, 1f), new Vector2(0f, -300f), 430f, 260f, new Vector2(0.5f, 1f));
		micInputSubPanel = panelManager.CreateSubPanel(settingsPanel, "Mic Input", new Vector2(0.5f, 1f), new Vector2(0.5f, 1f), new Vector2(0f, -580f), 430f, 80f, new Vector2(0.5f, 1f));
		egoBannerSubPanel = panelManager.CreateSubPanel(settingsPanel, "Ego Banner", new Vector2(0.5f, 1f), new Vector2(0.5f, 1f), new Vector2(0f, -680f), 430f, 30f, new Vector2(0.5f, 1f));
		npcNameSubPanel = panelManager.CreateSubPanel(thrallCustomizationPanel, "Name", new Vector2(0.5f, 1f), new Vector2(0.5f, 1f), new Vector2(0f, -100f), 400f, 80f, new Vector2(0.5f, 1f));
		npcPersonalitySubPanel = panelManager.CreateSubPanel(npcNameSubPanel, "Personality", new Vector2(0.5f, 1f), new Vector2(0.5f, 1f), new Vector2(0f, -90f), 400f, 250f, new Vector2(0.5f, 1f));
		npcVoiceSubPanel = panelManager.CreateSubPanel(npcPersonalitySubPanel, "Voice", new Vector2(0.5f, 1f), new Vector2(0.5f, 1f), new Vector2(0f, -260f), 400f, 110f, new Vector2(0.5f, 1f));
		npcBodyTypeSubPanel = panelManager.CreateSubPanel(npcVoiceSubPanel, "Body Type", new Vector2(0.5f, 1f), new Vector2(0.5f, 1f), new Vector2(0f, -120f), 400f, 100f, new Vector2(0.5f, 1f));
		npcAppearanceSubPanel = panelManager.CreateSubPanel(npcBodyTypeSubPanel, "Appearance", new Vector2(0.5f, 1f), new Vector2(0.5f, 1f), new Vector2(0f, -110f), 400f, 120f, new Vector2(0.5f, 1f));
		CreateScrollableTaskQueue();
		CreateKeyBindings();
		CreateMicInput();
		CreateEgoBanner();
		CreateNameSection();
		CreatePersonalitySection();
		CreateVoiceAndVolumeControls();
		CreateBodyTypeToggle();
		CreateAppearanceSection();
		CreateSaveButton();
	}

	private void CreateScrollableTaskQueue()
	{
		GameObject gameObject = GUIManager.Instance.CreateText("Task Queue", taskQueueSubPanel.transform, new Vector2(0f, 1f), new Vector2(0f, 1f), MenuSectionTitlePosition, GUIManager.Instance.AveriaSerifBold, MenuSectionTitleFontSize, Color.white, true, Color.black, 350f, 40f, false);
		gameObject.GetComponent<RectTransform>().pivot = new Vector2(0f, 1f);
		TaskListScrollBox = CreateScrollBox(taskQueueSubPanel, new Vector2(-10f, -10f), 400f, 140f);
	}

	public GameObject CreateScrollBox(GameObject parent, Vector2 position, float width, float height)
	{
		GameObject gameObject = new GameObject("ScrollView");
		gameObject.transform.SetParent(parent.transform, worldPositionStays: false);
		ScrollRect scrollRect = gameObject.AddComponent<ScrollRect>();
		RectTransform component = gameObject.GetComponent<RectTransform>();
		component.anchorMin = new Vector2(0.5f, 0.5f);
		component.anchorMax = new Vector2(0.5f, 0.5f);
		component.anchoredPosition = position;
		component.sizeDelta = new Vector2(width, height);
		GameObject gameObject2 = new GameObject("Viewport");
		gameObject2.transform.SetParent(gameObject.transform, worldPositionStays: false);
		RectTransform rectTransform = gameObject2.AddComponent<RectTransform>();
		rectTransform.anchorMin = Vector2.zero;
		rectTransform.anchorMax = Vector2.one;
		rectTransform.sizeDelta = new Vector2(-20f, 0f);
		rectTransform.anchoredPosition = Vector2.zero;
		Image image = gameObject2.AddComponent<Image>();
		image.color = Color.white;
		Mask mask = gameObject2.AddComponent<Mask>();
		mask.showMaskGraphic = false;
		GameObject gameObject3 = new GameObject("Content");
		gameObject3.transform.SetParent(gameObject2.transform, worldPositionStays: false);
		RectTransform rectTransform2 = gameObject3.AddComponent<RectTransform>();
		VerticalLayoutGroup verticalLayoutGroup = gameObject3.AddComponent<VerticalLayoutGroup>();
		ContentSizeFitter contentSizeFitter = gameObject3.AddComponent<ContentSizeFitter>();
		rectTransform2.anchorMin = new Vector2(0f, 1f);
		rectTransform2.anchorMax = new Vector2(1f, 1f);
		rectTransform2.pivot = new Vector2(0f, 1f);
		rectTransform2.sizeDelta = new Vector2(0f, 0f);
		rectTransform2.anchoredPosition = Vector2.zero;
		verticalLayoutGroup.padding = new RectOffset(10, 10, 10, 10);
		verticalLayoutGroup.spacing = 10f;
		verticalLayoutGroup.childAlignment = (TextAnchor)0;
		verticalLayoutGroup.childForceExpandWidth = true;
		verticalLayoutGroup.childControlWidth = true;
		contentSizeFitter.verticalFit = ContentSizeFitter.FitMode.PreferredSize;
		scrollRect.content = rectTransform2;
		scrollRect.viewport = rectTransform;
		scrollRect.horizontal = false;
		scrollRect.vertical = true;
		GameObject gameObject4 = new GameObject("Scrollbar");
		gameObject4.transform.SetParent(gameObject.transform, worldPositionStays: false);
		Scrollbar scrollbar = gameObject4.AddComponent<Scrollbar>();
		Image image2 = gameObject4.AddComponent<Image>();
		image2.color = new Color(0.5f, 0.5f, 0.5f, 0.5f);
		RectTransform component2 = gameObject4.GetComponent<RectTransform>();
		component2.anchorMin = new Vector2(1f, 0f);
		component2.anchorMax = Vector2.one;
		component2.sizeDelta = new Vector2(20f, 0f);
		component2.anchoredPosition = Vector2.zero;
		GameObject gameObject5 = new GameObject("Handle");
		gameObject5.transform.SetParent(gameObject4.transform, worldPositionStays: false);
		Image image3 = gameObject5.AddComponent<Image>();
		image3.color = new Color(0.7f, 0.7f, 0.7f, 0.7f);
		RectTransform component3 = gameObject5.GetComponent<RectTransform>();
		component3.sizeDelta = Vector2.zero;
		scrollbar.handleRect = component3;
		scrollbar.direction = Scrollbar.Direction.BottomToTop;
		scrollRect.verticalScrollbar = scrollbar;
		return gameObject;
	}

	public void AddItemToScrollBox(GameObject scrollBox, string text, Sprite icon, int index)
	{
		Transform transform = scrollBox.transform.Find("Viewport/Content");
		if (transform != null)
		{
			GameObject itemObject = new GameObject("Item");
			itemObject.transform.SetParent(transform, worldPositionStays: false);
			HorizontalLayoutGroup horizontalLayoutGroup = itemObject.AddComponent<HorizontalLayoutGroup>();
			horizontalLayoutGroup.padding = new RectOffset(5, 5, 5, 5);
			horizontalLayoutGroup.spacing = 10f;
			horizontalLayoutGroup.childAlignment = (TextAnchor)3;
			horizontalLayoutGroup.childForceExpandWidth = false;
			horizontalLayoutGroup.childControlWidth = true;
			LayoutElement layoutElement = itemObject.AddComponent<LayoutElement>();
			layoutElement.minHeight = 40f;
			layoutElement.flexibleWidth = 1f;
			GameObject gameObject = new GameObject("Icon");
			gameObject.transform.SetParent(itemObject.transform, worldPositionStays: false);
			Image image = gameObject.AddComponent<Image>();
			image.sprite = icon;
			RectTransform component = gameObject.GetComponent<RectTransform>();
			component.sizeDelta = new Vector2(30f, 30f);
			LayoutElement layoutElement2 = gameObject.AddComponent<LayoutElement>();
			layoutElement2.minWidth = 30f;
			layoutElement2.minHeight = 30f;
			layoutElement2.flexibleWidth = 0f;
			GameObject gameObject2 = new GameObject("Text");
			gameObject2.transform.SetParent(itemObject.transform, worldPositionStays: false);
			Text text2 = gameObject2.AddComponent<Text>();
			text2.text = text;
			text2.font = GUIManager.Instance.AveriaSerifBold;
			text2.fontSize = 17;
			text2.color = ((index == 0) ? Color.white : Color.gray);
			text2.alignment = (TextAnchor)3;
			text2.horizontalOverflow = (HorizontalWrapMode)0;
			text2.verticalOverflow = (VerticalWrapMode)0;
			RectTransform component2 = gameObject2.GetComponent<RectTransform>();
			LayoutElement layoutElement3 = gameObject2.AddComponent<LayoutElement>();
			layoutElement3.flexibleWidth = 1f;
			layoutElement3.minWidth = 0f;
			GameObject gameObject3 = new GameObject("Spacer");
			gameObject3.transform.SetParent(itemObject.transform, worldPositionStays: false);
			LayoutElement layoutElement4 = gameObject3.AddComponent<LayoutElement>();
			layoutElement4.flexibleWidth = 1f;
			GameObject gameObject4 = new GameObject("DeleteButton");
			gameObject4.transform.SetParent(itemObject.transform, worldPositionStays: false);
			Button button = gameObject4.AddComponent<Button>();
			Image image2 = gameObject4.AddComponent<Image>();
			image2.color = Color.clear;
			RectTransform component3 = gameObject4.GetComponent<RectTransform>();
			component3.sizeDelta = new Vector2(25f, 25f);
			LayoutElement layoutElement5 = gameObject4.AddComponent<LayoutElement>();
			layoutElement5.minWidth = 25f;
			layoutElement5.minHeight = 25f;
			layoutElement5.flexibleWidth = 0f;
			layoutElement5.preferredWidth = 25f;
			GameObject gameObject5 = new GameObject("ButtonText");
			gameObject5.transform.SetParent(gameObject4.transform, worldPositionStays: false);
			Text text3 = gameObject5.AddComponent<Text>();
			text3.text = "X";
			text3.font = Resources.GetBuiltinResource<Font>("Arial.ttf");
			text3.fontSize = 18;
			text3.color = Color.white;
			text3.alignment = (TextAnchor)4;
			RectTransform component4 = gameObject5.GetComponent<RectTransform>();
			component4.anchorMin = Vector2.zero;
			component4.anchorMax = Vector2.one;
			component4.sizeDelta = Vector2.zero;
			button.onClick.AddListener(delegate
			{
				UnityEngine.Object.Destroy(itemObject);
				LogMessage($"Removing npc command [{index}]");
				instance.commandManager.RemoveCommand(index);
				instance.RefreshTaskList();
			});
			CollectionExtensions.AddItem<GameObject>((IEnumerable<GameObject>)TasksList, itemObject);
		}
	}

	public void DeleteAllTasks()
	{
		Transform transform = TaskListScrollBox.transform.Find("Viewport/Content");
		if (!(transform != null))
		{
			return;
		}
		foreach (Transform item in transform)
		{
			UnityEngine.Object.Destroy(item.gameObject);
		}
	}

	public void RefreshTaskList()
	{
		DeleteAllTasks();
		Sprite icon = Sprite.Create(Texture2D.whiteTexture, new Rect(0f, 0f, 1f, 1f), Vector2.one * 0.5f);
		int num = 0;
		foreach (NPCCommand allCommand in instance.commandManager.GetAllCommands())
		{
			if (allCommand is HarvestAction)
			{
				HarvestAction harvestAction = (HarvestAction)allCommand;
				AddItemToScrollBox(TaskListScrollBox, $"Gathering {harvestAction.ResourceName} ({harvestAction.RequiredAmount})", icon, num);
			}
			if (allCommand is PatrolAction)
			{
				PatrolAction patrolAction = (PatrolAction)allCommand;
				AddItemToScrollBox(TaskListScrollBox, "Patrolling area: " + patrolAction.patrol_position.ToString(), icon, num);
			}
			if (allCommand is AttackAction)
			{
				AttackAction attackAction = (AttackAction)allCommand;
				AddItemToScrollBox(TaskListScrollBox, $"Attacking: {attackAction.TargetName} ({attackAction.TargetQuantity})", icon, num);
			}
			if (allCommand is FollowAction)
			{
				AddItemToScrollBox(TaskListScrollBox, "Following Player", icon, num);
			}
			num++;
		}
	}

	private IEnumerator ListenForNewKeybind(int keybindIndex)
	{
		yield return new WaitForSeconds(0.1f);
		while (true)
		{
			foreach (KeyCode keyCode in Enum.GetValues(typeof(KeyCode)))
			{
				if (!ZInput.GetKeyDown(keyCode, logWarning: false))
				{
					continue;
				}
				bool flag = false;
				foreach (ConfigEntry<KeyCode> entry in allKeybinds)
				{
					if (entry.Value == keyCode)
					{
						LogError($"{keyCode.ToString()} is already used for {((ConfigEntryBase)entry).Definition}!");
						flag = true;
						yield return null;
					}
				}
				if (!flag)
				{
					allKeybinds[keybindIndex].Value = keyCode;
					LogWarning($"Keybind for {((ConfigEntryBase)allKeybinds[keybindIndex]).Definition} set to Key: {keyCode.ToString()}");
				}
				RefreshKeyBindings();
				yield break;
			}
			yield return null;
		}
	}

	private void RefreshKeyBindings()
	{
		foreach (Transform item in keybindsSubPanel.transform)
		{
			UnityEngine.Object.Destroy(item.gameObject);
		}
		editButtons.Clear();
		CreateKeyBindings();
	}

	private void CreateKeyBindings()
	{
		string[] array = new string[7]
		{
			"[" + spawnKey.Value.ToString() + "]",
			"[" + harvestKey.Value.ToString() + "]",
			"[" + followKey.Value.ToString() + "]",
			"[" + inventoryKey.Value.ToString() + "]",
			"[" + talkKey.Value.ToString() + "]",
			"[" + thrallMenuKey.Value.ToString() + "]",
			"[" + combatModeKey.Value.ToString() + "]"
		};
		string[] array2 = new string[7] { "Spawn/Dismiss", "Harvest", "Follow/Patrol", "Inventory", "Push To Talk", "Thrall Menu", "Switch Combat Mode" };
		GameObject gameObject = GUIManager.Instance.CreateText("Keybinds", keybindsSubPanel.transform, new Vector2(0f, 1f), new Vector2(0f, 1f), MenuSectionTitlePosition, GUIManager.Instance.AveriaSerifBold, MenuSectionTitleFontSize, Color.white, true, Color.black, 350f, 40f, false);
		gameObject.GetComponent<RectTransform>().pivot = new Vector2(0f, 1f);
		for (int i = 0; i < array.Length; i++)
		{
			GameObject gameObject2 = new GameObject($"KeybindRow_{i}");
			RectTransform rectTransform = gameObject2.AddComponent<RectTransform>();
			rectTransform.SetParent(keybindsSubPanel.transform, worldPositionStays: false);
			rectTransform.anchorMin = new Vector2(0f, 1f);
			rectTransform.anchorMax = new Vector2(1f, 1f);
			rectTransform.anchoredPosition = new Vector2(10f, -60f - (float)(i * 30));
			rectTransform.sizeDelta = new Vector2(0f, 30f);
			GameObject gameObject3 = GUIManager.Instance.CreateText(array[i], gameObject2.transform, new Vector2(0f, 0f), new Vector2(1f, 1f), Vector2.zero, GUIManager.Instance.AveriaSerif, 20, GUIManager.Instance.ValheimYellow, true, Color.black, 300f, 30f, false);
			GameObject gameObject4 = GUIManager.Instance.CreateText(array2[i], gameObject2.transform, new Vector2(0f, 0f), new Vector2(1f, 1f), new Vector2(35f, 0f), GUIManager.Instance.AveriaSerif, 20, Color.white, true, Color.black, 300f, 30f, false);
			RectTransform component = gameObject3.GetComponent<RectTransform>();
			component.pivot = new Vector2(0f, 1f);
			component.anchoredPosition = Vector2.zero;
			RectTransform component2 = gameObject4.GetComponent<RectTransform>();
			component2.pivot = new Vector2(0f, 1f);
			GameObject gameObject5 = GUIManager.Instance.CreateButton("Edit", gameObject2.transform, new Vector2(1f, 0f), new Vector2(1f, 1f), new Vector2(-5f, 0f), 60f, 25f);
			RectTransform component3 = gameObject5.GetComponent<RectTransform>();
			component3.pivot = new Vector2(1f, 1f);
			component3.anchoredPosition = new Vector2(-20f, 0f);
			Button component4 = gameObject5.GetComponent<Button>();
			int index = i;
			component4.onClick.AddListener(delegate
			{
				OnEditKeybind(index);
			});
			editButtons.Add(component4);
		}
	}

	private void OnEditKeybind(int index)
	{
		foreach (Button editButton in editButtons)
		{
			editButton.interactable = false;
		}
		if (allKeybinds.Count >= 0 && allKeybinds.Count > index)
		{
			LogInfo("Waiting for new keybind...");
			((MonoBehaviour)this).StartCoroutine(ListenForNewKeybind(index));
		}
	}

	private void CreateMicInput()
	{
		GameObject gameObject = GUIManager.Instance.CreateText("Mic Input", micInputSubPanel.transform, new Vector2(0f, 1f), new Vector2(0f, 1f), MenuSectionTitlePosition, GUIManager.Instance.AveriaSerifBold, 26, Color.white, true, Color.black, 350f, 40f, false);
		gameObject.GetComponent<RectTransform>().pivot = new Vector2(0f, 1f);
		GameObject gameObject2 = GUIManager.Instance.CreateDropDown(micInputSubPanel.transform, new Vector2(0f, 1f), new Vector2(0f, 1f), new Vector2(0f, 0f), 16, 280f, 30f);
		micDropdownComp = gameObject2.GetComponent<Dropdown>();
		List<string> options = (from option in Microphone.devices.ToList()
			select TruncateText(option, 27)).ToList();
		micDropdownComp.AddOptions(options);
		RectTransform component = gameObject2.GetComponent<RectTransform>();
		component.pivot = new Vector2(0f, 1f);
		component.anchoredPosition = new Vector2(10f, -40f);
		micDropdownComp.onValueChanged.AddListener(OnMicInputDropdownChanged);
	}

	private string TruncateText(string text, int maxLength)
	{
		if (string.IsNullOrEmpty(text) || text.Length <= maxLength)
		{
			return text;
		}
		return text.Substring(0, maxLength - 3) + "...";
	}

	private void OnMicInputDropdownChanged(int index)
	{
		instance.MicrophoneIndex = index;
		LogWarning("New microphone picked: " + Microphone.devices[index]);
	}

	private void CreateEgoBanner()
	{
		GameObject gameObject = GUIManager.Instance.CreateText("ego.ai's Discord Server", egoBannerSubPanel.transform, new Vector2(0f, 1f), new Vector2(0f, 1f), new Vector2(10f, -2f), GUIManager.Instance.AveriaSerifBold, 22, Color.white, true, Color.blue, 350f, 40f, false);
		RectTransform component = gameObject.GetComponent<RectTransform>();
		component.pivot = new Vector2(0f, 1f);
		EventTrigger eventTrigger = gameObject.AddComponent<EventTrigger>();
		EventTrigger.Entry entry = new EventTrigger.Entry();
		entry.eventID = EventTriggerType.PointerClick;
		entry.callback.AddListener(delegate
		{
			OnClickEgoBanner();
		});
		eventTrigger.triggers.Add(entry);
	}

	private void OnClickEgoBanner()
	{
		string url = "https://discord.gg/egoai";
		Application.OpenURL(url);
		LogInfo("Ego discord url clicked!");
	}

	private void CreateNameSection()
	{
		GameObject gameObject = GUIManager.Instance.CreateText("Name", npcNameSubPanel.transform, new Vector2(0f, 1f), new Vector2(0f, 1f), MenuSectionTitlePosition, GUIManager.Instance.AveriaSerifBold, instance.MenuSectionTitleFontSize, Color.white, true, Color.black, 350f, 40f, false);
		gameObject.GetComponent<RectTransform>().pivot = new Vector2(0f, 1f);
		CreateNameInputField(npcNameSubPanel.transform, "Bilbo");
	}

	public void CreateNameInputField(Transform parent, string placeholder, int fontSize = 18, int width = 380, int height = 30)
	{
		GameObject gameObject = new GameObject("CustomInputField");
		gameObject.transform.SetParent(parent, worldPositionStays: false);
		Image image = gameObject.AddComponent<Image>();
		image.color = new Color(0.7f, 0.7f, 0.7f, 0.3f);
		nameInputField = gameObject.AddComponent<InputField>();
		nameInputField.lineType = InputField.LineType.SingleLine;
		nameInputField.onValueChanged.AddListener(OnNPCNameChanged);
		RectTransform component = nameInputField.GetComponent<RectTransform>();
		component.sizeDelta = new Vector2(width, height);
		component.anchoredPosition = new Vector2(0f, -15f);
		GameObject gameObject2 = new GameObject("Placeholder");
		gameObject2.transform.SetParent(gameObject.transform, worldPositionStays: false);
		Text text = gameObject2.AddComponent<Text>();
		text.text = placeholder;
		text.font = GUIManager.Instance.AveriaSerifBold;
		text.fontSize = fontSize;
		text.color = new Color(0.7f, 0.7f, 0.7f, 0.5f);
		RectTransform component2 = text.GetComponent<RectTransform>();
		component2.anchorMin = Vector2.zero;
		component2.anchorMax = Vector2.one;
		component2.offsetMin = new Vector2(10f, 0f);
		component2.offsetMax = new Vector2(-10f, 0f);
		component2.anchoredPosition = new Vector2(0f, -4f);
		GameObject gameObject3 = new GameObject("Text");
		gameObject3.transform.SetParent(gameObject.transform, worldPositionStays: false);
		Text text2 = gameObject3.AddComponent<Text>();
		text2.font = GUIManager.Instance.AveriaSerifBold;
		text2.fontSize = fontSize;
		text2.color = Color.white;
		RectTransform component3 = text2.GetComponent<RectTransform>();
		component3.anchorMin = Vector2.zero;
		component3.anchorMax = Vector2.one;
		component3.offsetMin = new Vector2(10f, 0f);
		component3.offsetMax = new Vector2(-10f, 0f);
		component3.anchoredPosition = new Vector2(0f, -4f);
		nameInputField.placeholder = text;
		nameInputField.textComponent = text2;
	}

	private void OnNPCNameChanged(string newValue)
	{
		if ((bool)PlayerNPC)
		{
			instance.npcName = newValue;
			HumanoidNPC component = PlayerNPC.GetComponent<HumanoidNPC>();
			component.m_name = newValue;
			nameInputField.SetTextWithoutNotify(newValue);
		}
	}

	private void CreatePersonalitySection()
	{
		GameObject gameObject = GUIManager.Instance.CreateText("Personality", npcPersonalitySubPanel.transform, new Vector2(0f, 1f), new Vector2(0f, 1f), MenuSectionTitlePosition, GUIManager.Instance.AveriaSerifBold, instance.MenuSectionTitleFontSize, Color.white, true, Color.black, 350f, 40f, false);
		RectTransform component = gameObject.GetComponent<RectTransform>();
		component.pivot = new Vector2(0f, 1f);
		GameObject gameObject2 = GUIManager.Instance.CreateDropDown(npcPersonalitySubPanel.transform, new Vector2(0f, 1f), new Vector2(0f, 1f), new Vector2(10f, -40f), 20, 300f, 30f);
		component = gameObject2.GetComponent<RectTransform>();
		component.pivot = new Vector2(0f, 1f);
		instance.personalityDropdownComp = gameObject2.GetComponent<Dropdown>();
		instance.personalityDropdownComp.AddOptions(npcPersonalities);
		instance.personalityDropdownComp.onValueChanged.AddListener(OnNPCPersonalityDropdownChanged);
		CreateMultilineInputField(npcPersonalitySubPanel.transform, "She's strong, stoic, tomboyish, confident and serious...", 14);
	}

	private void OnNPCPersonalityDropdownChanged(int index)
	{
		instance.npcPersonalityIndex = index;
		if (index < npcPersonalities.Count - 1)
		{
			instance.npcPersonality = npcPersonalitiesMap[npcPersonalities[index]];
			instance.personalityInputField.SetTextWithoutNotify(npcPersonalitiesMap[npcPersonalities[index]]);
			if ((bool)PlayerNPC)
			{
				instance.OnNPCNameChanged(npcPersonalities[index]);
			}
		}
		LogInfo("New NPCPersonality picked from dropdown: " + npcPersonalities[instance.npcPersonalityIndex]);
	}

	public void CreateMultilineInputField(Transform parent, string placeholder, int fontSize = 16, int width = 380, int height = 150)
	{
		GameObject gameObject = new GameObject("CustomInputField");
		gameObject.transform.SetParent(parent, worldPositionStays: false);
		Image image = gameObject.AddComponent<Image>();
		image.color = new Color(0.7f, 0.7f, 0.7f, 0.3f);
		personalityInputField = gameObject.AddComponent<InputField>();
		personalityInputField.lineType = InputField.LineType.MultiLineNewline;
		personalityInputField.onValueChanged.AddListener(OnPersonalityTextChanged);
		RectTransform component = personalityInputField.GetComponent<RectTransform>();
		component.sizeDelta = new Vector2(width, height);
		component.position += new Vector3(0f, -40f, 0f);
		GameObject gameObject2 = new GameObject("Placeholder");
		gameObject2.transform.SetParent(gameObject.transform, worldPositionStays: false);
		Text text = gameObject2.AddComponent<Text>();
		text.text = placeholder;
		text.font = GUIManager.Instance.AveriaSerifBold;
		text.fontSize = fontSize;
		text.color = new Color(0.7f, 0.7f, 0.7f, 0.5f);
		RectTransform component2 = text.GetComponent<RectTransform>();
		component2.anchorMin = new Vector2(0f, 0f);
		component2.anchorMax = new Vector2(1f, 1f);
		component2.offsetMin = new Vector2(10f, 10f);
		component2.offsetMax = new Vector2(-10f, -10f);
		GameObject gameObject3 = new GameObject("Text");
		gameObject3.transform.SetParent(gameObject.transform, worldPositionStays: false);
		Text text2 = gameObject3.AddComponent<Text>();
		text2.font = GUIManager.Instance.AveriaSerifBold;
		text2.fontSize = fontSize;
		text2.color = Color.white;
		RectTransform component3 = text2.GetComponent<RectTransform>();
		component3.anchorMin = new Vector2(0f, 0f);
		component3.anchorMax = new Vector2(1f, 1f);
		component3.offsetMin = new Vector2(10f, 10f);
		component3.offsetMax = new Vector2(-10f, -10f);
		personalityInputField.placeholder = text;
		personalityInputField.textComponent = text2;
	}

	private void OnPersonalityTextChanged(string newText)
	{
		instance.personalityDropdownComp.SetValueWithoutNotify(npcPersonalities.Count - 1);
		instance.npcPersonality = newText;
	}

	private void CreateVoiceAndVolumeControls()
	{
		GameObject gameObject = GUIManager.Instance.CreateText("Voice", npcVoiceSubPanel.transform, new Vector2(0f, 1f), new Vector2(0f, 1f), MenuSectionTitlePosition, GUIManager.Instance.AveriaSerifBold, MenuSectionTitleFontSize, Color.white, true, Color.black, 350f, 40f, false);
		gameObject.GetComponent<RectTransform>().pivot = new Vector2(0f, 1f);
		GameObject gameObject2 = GUIManager.Instance.CreateDropDown(npcVoiceSubPanel.transform, new Vector2(0f, 1f), new Vector2(0f, 1f), new Vector2(110f, -50f), 20, 200f, 30f);
		instance.voiceDropdownComp = gameObject2.GetComponent<Dropdown>();
		instance.voiceDropdownComp.AddOptions(npcVoices);
		instance.voiceDropdownComp.onValueChanged.AddListener(OnNPCVoiceDropdownChanged);
		instance.previewVoiceButton = GUIManager.Instance.CreateButton("Preview", gameObject2.transform, new Vector2(0.5f, 0f), new Vector2(0.5f, 0f), new Vector2(190f, 0f), 100f, 30f);
		instance.previewVoiceButton.GetComponent<RectTransform>().pivot = new Vector2(0.5f, 0f);
		instance.previewVoiceButtonComp = instance.previewVoiceButton.GetComponent<Button>();
		instance.previewVoiceButtonComp.onClick.AddListener(delegate
		{
			OnPreviewVoiceButtonClick(instance.previewVoiceButtonComp);
		});
		gameObject = GUIManager.Instance.CreateText("Volume", npcVoiceSubPanel.transform, new Vector2(0f, 1f), new Vector2(0f, 1f), new Vector2(10f, -75f), GUIManager.Instance.AveriaSerifBold, 20, Color.white, true, Color.black, 350f, 40f, false);
		gameObject.GetComponent<RectTransform>().pivot = new Vector2(0f, 1f);
		Slider slider = CreateSlider(npcVoiceSubPanel.transform, new Vector2(0f, 1f), new Vector2(0f, 1f), new Vector2(230f, -87.5f), 250f, 15f);
		instance.volumeSliderComp = slider.GetComponent<Slider>();
		instance.volumeSliderComp.onValueChanged.AddListener(OnVolumeSliderValueChanged);
	}

	private void CreatePreviewVoiceButton()
	{
	}

	private void OnPreviewVoiceButtonClick(Button button)
	{
		instance.BrainSynthesizeAudio("Hello, I am your friend sent by the team at Ego", npcVoices[instance.npcVoice].ToLower());
		SetPreviewVoiceButtonState(button, interactable: false, 0.5f);
	}

	private void SetPreviewVoiceButtonState(Button button, bool interactable, float opacity)
	{
		button.interactable = interactable;
		Image component = button.GetComponent<Image>();
		if (component != null)
		{
			Color color = component.color;
			color.a = opacity;
			component.color = color;
		}
		Text componentInChildren = button.GetComponentInChildren<Text>();
		if (componentInChildren != null)
		{
			Color color2 = componentInChildren.color;
			color2.a = opacity;
			componentInChildren.color = color2;
		}
	}

	private void OnNPCVoiceDropdownChanged(int index)
	{
		instance.npcVoice = index;
		LogInfo("New NPCVoice picked: " + npcVoices[instance.npcVoice]);
	}

	private void OnVolumeSliderValueChanged(float value)
	{
		instance.npcVolume = value;
	}

	private void CreateBodyTypeToggle()
	{
		GameObject gameObject = GUIManager.Instance.CreateText("Body Type", npcBodyTypeSubPanel.transform, new Vector2(0f, 1f), new Vector2(0f, 1f), MenuSectionTitlePosition, GUIManager.Instance.AveriaSerifBold, MenuSectionTitleFontSize, Color.white, true, Color.black, 350f, 40f, false);
		gameObject.GetComponent<RectTransform>().pivot = new Vector2(0f, 1f);
		GameObject gameObject2 = CreateToggle(npcBodyTypeSubPanel.transform, "Masculine", "Masculine", -20f);
		GameObject gameObject3 = CreateToggle(npcBodyTypeSubPanel.transform, "Feminine", "Feminine", -50f);
		instance.toggleMasculine = gameObject2.GetComponent<Toggle>();
		instance.toggleFeminine = gameObject3.GetComponent<Toggle>();
		instance.toggleMasculine.isOn = true;
		instance.toggleMasculine.onValueChanged.AddListener(delegate(bool isOn)
		{
			OnBodyTypeToggleChanged(instance.toggleMasculine, instance.toggleFeminine, isOn);
		});
		instance.toggleFeminine.onValueChanged.AddListener(delegate(bool isOn)
		{
			OnBodyTypeToggleChanged(instance.toggleFeminine, instance.toggleMasculine, isOn);
		});
	}

	private void OnBodyTypeToggleChanged(Toggle changedToggle, Toggle otherToggle, bool isOn)
	{
		if (isOn && otherToggle.isOn)
		{
			otherToggle.isOn = false;
		}
		instance.npcGender = ((!(changedToggle.name == "Masculine")) ? 1 : 0);
		if ((bool)PlayerNPC)
		{
			VisEquipment component = PlayerNPC.GetComponent<VisEquipment>();
			component.SetModel(instance.npcGender);
		}
		LogInfo("New NPCGender picked: " + changedToggle.name);
	}

	private void CreateAppearanceSection()
	{
		GameObject gameObject = GUIManager.Instance.CreateText("Appearance", npcAppearanceSubPanel.transform, new Vector2(0f, 1f), new Vector2(0f, 1f), MenuSectionTitlePosition, GUIManager.Instance.AveriaSerifBold, MenuSectionTitleFontSize, Color.white, true, Color.black, 350f, 40f, false);
		gameObject.GetComponent<RectTransform>().pivot = new Vector2(0f, 1f);
		GameObject gameObject2 = GUIManager.Instance.CreateButton("", npcAppearanceSubPanel.transform, new Vector2(0f, 1f), new Vector2(0f, 1f), new Vector2(10f, -40f), 50f, 30f);
		gameObject2.GetComponent<RectTransform>().pivot = new Vector2(0f, 1f);
		GameObject gameObject3 = GUIManager.Instance.CreateText("Skin Tone", gameObject2.transform, new Vector2(0f, 1f), new Vector2(0f, 1f), new Vector2(60f, -3f), GUIManager.Instance.AveriaSerifBold, 20, Color.white, true, Color.black, 350f, 40f, false);
		gameObject3.GetComponent<RectTransform>().pivot = new Vector2(0f, 1f);
		gameObject2.GetComponent<Button>().onClick.AddListener(CreateSkinColorPicker);
		GameObject gameObject4 = GUIManager.Instance.CreateButton("", npcAppearanceSubPanel.transform, new Vector2(0f, 1f), new Vector2(0f, 1f), new Vector2(10f, -80f), 50f, 30f);
		gameObject4.GetComponent<RectTransform>().pivot = new Vector2(0f, 1f);
		GameObject gameObject5 = GUIManager.Instance.CreateText("Hair Color", gameObject4.transform, new Vector2(0f, 1f), new Vector2(0f, 1f), new Vector2(60f, -3f), GUIManager.Instance.AveriaSerifBold, 20, Color.white, true, Color.black, 350f, 40f, false);
		gameObject5.GetComponent<RectTransform>().pivot = new Vector2(0f, 1f);
		gameObject4.GetComponent<Button>().onClick.AddListener(CreateHairColorPicker);
	}

	private void CreateSkinColorPicker()
	{
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Expected O, but got Unknown
		//IL_005b: Expected O, but got Unknown
		GUIManager.Instance.CreateColorPicker(new Vector2(0f, 1f), new Vector2(0f, 1f), new Vector2(500f, -500f), Color.yellow, "Skin Tone", new ColorEvent(OnSkinColorChanged), new ColorEvent(OnSkinColorSelected), false);
	}

	private void OnSkinColorChanged(Color changedColor)
	{
		if ((bool)PlayerNPC)
		{
			HumanoidNPC component = PlayerNPC.GetComponent<HumanoidNPC>();
			((Humanoid)component).m_visEquipment.SetSkinColor(new Vector3(instance.skinColor.r, instance.skinColor.g, instance.skinColor.b));
		}
	}

	private void OnSkinColorSelected(Color selectedColor)
	{
		if ((bool)PlayerNPC)
		{
			instance.skinColor = selectedColor;
			HumanoidNPC component = PlayerNPC.GetComponent<HumanoidNPC>();
			((Humanoid)component).m_visEquipment.SetSkinColor(new Vector3(instance.skinColor.r, instance.skinColor.g, instance.skinColor.b));
			LogInfo($"Selected color: {instance.skinColor}");
		}
	}

	private void CreateHairColorPicker()
	{
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Expected O, but got Unknown
		//IL_005b: Expected O, but got Unknown
		GUIManager.Instance.CreateColorPicker(new Vector2(0f, 1f), new Vector2(0f, 1f), new Vector2(500f, -500f), Color.yellow, "Hair Color", new ColorEvent(OnHairColorChanged), new ColorEvent(OnHairColorSelected), false);
	}

	private void OnHairColorChanged(Color changedColor)
	{
		if ((bool)PlayerNPC)
		{
			HumanoidNPC component = PlayerNPC.GetComponent<HumanoidNPC>();
			((Humanoid)component).m_visEquipment.SetHairColor(new Vector3(instance.hairColor.r, instance.hairColor.g, instance.hairColor.b));
		}
	}

	private void OnHairColorSelected(Color selectedColor)
	{
		if ((bool)PlayerNPC)
		{
			instance.hairColor = selectedColor;
			HumanoidNPC component = PlayerNPC.GetComponent<HumanoidNPC>();
			((Humanoid)component).m_visEquipment.SetHairColor(new Vector3(instance.hairColor.r, instance.hairColor.g, instance.hairColor.b));
			LogInfo($"Selected color: {instance.hairColor}");
		}
	}

	private void CreateSaveButton()
	{
		GameObject gameObject = GUIManager.Instance.CreateButton("SAVE", thrallCustomizationPanel.transform, new Vector2(0.5f, 0f), new Vector2(0.5f, 0f), new Vector2(0f, 25f), 250f, 40f);
		gameObject.GetComponent<RectTransform>().pivot = new Vector2(0.5f, 0f);
		Button saveButtonComp = gameObject.GetComponent<Button>();
		saveButtonComp.onClick.AddListener(delegate
		{
			OnSaveButtonClick(saveButtonComp);
		});
	}

	private void OnSaveButtonClick(Button button)
	{
		instance.panelManager.TogglePanel("Settings");
		instance.panelManager.TogglePanel("Thrall Customization");
		IsModMenuShowing = false;
		GUIManager.BlockInput(false);
		if ((bool)PlayerNPC)
		{
			SaveNPCData(PlayerNPC);
		}
	}

	private Slider CreateSlider(Transform parent, Vector2 anchorMin, Vector2 anchorMax, Vector2 position, float width, float height)
	{
		GameObject gameObject = new GameObject("VolumeSlider", typeof(RectTransform));
		gameObject.transform.SetParent(parent, worldPositionStays: false);
		RectTransform component = gameObject.GetComponent<RectTransform>();
		component.anchorMin = anchorMin;
		component.anchorMax = anchorMax;
		component.anchoredPosition = position;
		component.sizeDelta = new Vector2(width, height);
		component.pivot = new Vector2(0.5f, 0.5f);
		Slider slider = gameObject.AddComponent<Slider>();
		slider.minValue = 0f;
		slider.maxValue = 100f;
		slider.value = 90f;
		GameObject gameObject2 = new GameObject("Background", typeof(RectTransform), typeof(Image));
		gameObject2.transform.SetParent(gameObject.transform, worldPositionStays: false);
		gameObject2.GetComponent<Image>().color = new Color(0.2f, 0.2f, 0.2f);
		RectTransform component2 = gameObject2.GetComponent<RectTransform>();
		component2.anchorMin = Vector2.zero;
		component2.anchorMax = Vector2.one;
		component2.sizeDelta = Vector2.zero;
		GameObject gameObject3 = new GameObject("Fill Area", typeof(RectTransform));
		gameObject3.transform.SetParent(gameObject.transform, worldPositionStays: false);
		RectTransform component3 = gameObject3.GetComponent<RectTransform>();
		component3.anchorMin = new Vector2(0f, 0.25f);
		component3.anchorMax = new Vector2(1f, 0.75f);
		component3.sizeDelta = Vector2.zero;
		GameObject gameObject4 = new GameObject("Fill", typeof(RectTransform), typeof(Image));
		gameObject4.transform.SetParent(gameObject3.transform, worldPositionStays: false);
		gameObject4.GetComponent<Image>().color = new Color(0.7f, 0.7f, 0.7f);
		RectTransform component4 = gameObject4.GetComponent<RectTransform>();
		component4.anchorMin = Vector2.zero;
		component4.anchorMax = Vector2.one;
		component4.sizeDelta = Vector2.zero;
		GameObject gameObject5 = new GameObject("Handle Slide Area", typeof(RectTransform));
		gameObject5.transform.SetParent(gameObject.transform, worldPositionStays: false);
		RectTransform component5 = gameObject5.GetComponent<RectTransform>();
		component5.anchorMin = Vector2.zero;
		component5.anchorMax = Vector2.one;
		component5.sizeDelta = Vector2.zero;
		GameObject gameObject6 = new GameObject("Handle", typeof(RectTransform), typeof(Image));
		gameObject6.transform.SetParent(gameObject5.transform, worldPositionStays: false);
		gameObject6.GetComponent<Image>().color = GUIManager.Instance.ValheimOrange;
		RectTransform component6 = gameObject6.GetComponent<RectTransform>();
		component6.anchorMin = Vector2.zero;
		component6.anchorMax = Vector2.one;
		component6.sizeDelta = new Vector2(20f, 0f);
		slider.fillRect = component4;
		slider.handleRect = component6;
		slider.targetGraphic = gameObject6.GetComponent<Image>();
		return slider;
	}

	private GameObject CreateToggle(Transform parent, string name, string label, float positionY)
	{
		GameObject gameObject = new GameObject(name, typeof(RectTransform), typeof(Toggle));
		gameObject.transform.SetParent(parent, worldPositionStays: false);
		RectTransform component = gameObject.GetComponent<RectTransform>();
		component.anchorMin = new Vector2(0f, 1f);
		component.anchorMax = new Vector2(0f, 1f);
		component.anchoredPosition = new Vector2(10f, positionY);
		component.sizeDelta = Vector2.zero;
		Toggle component2 = gameObject.GetComponent<Toggle>();
		CreateToggleVisuals(component2, label);
		return gameObject;
	}

	private void CreateToggleVisuals(Toggle toggle, string label)
	{
		GameObject gameObject = new GameObject("Background", typeof(RectTransform), typeof(Image));
		gameObject.transform.SetParent(toggle.transform, worldPositionStays: false);
		RectTransform component = gameObject.GetComponent<RectTransform>();
		component.anchorMin = new Vector2(0f, 0.5f);
		component.anchorMax = new Vector2(0f, 0.5f);
		component.anchoredPosition = new Vector2(10f, -30f);
		component.sizeDelta = new Vector2(20f, 20f);
		Image component2 = gameObject.GetComponent<Image>();
		component2.sprite = CreateCircleSprite();
		component2.color = Color.white;
		GameObject gameObject2 = new GameObject("Checkmark", typeof(RectTransform), typeof(Image));
		gameObject2.transform.SetParent(gameObject.transform, worldPositionStays: false);
		RectTransform component3 = gameObject2.GetComponent<RectTransform>();
		component3.anchorMin = new Vector2(0.15f, 0.15f);
		component3.anchorMax = new Vector2(0.85f, 0.85f);
		component3.sizeDelta = Vector2.zero;
		Image component4 = gameObject2.GetComponent<Image>();
		component4.sprite = CreateCircleSprite();
		component4.color = GUIManager.Instance.ValheimOrange;
		toggle.targetGraphic = component2;
		toggle.graphic = component4;
		GameObject gameObject3 = new GameObject("Label", typeof(RectTransform), typeof(Text));
		gameObject3.transform.SetParent(toggle.transform, worldPositionStays: false);
		RectTransform component5 = gameObject3.GetComponent<RectTransform>();
		component5.anchorMin = new Vector2(1f, 1f);
		component5.anchorMax = new Vector2(1f, 1f);
		component5.anchoredPosition = new Vector2(80f, -30f);
		Text component6 = gameObject3.GetComponent<Text>();
		component6.text = label;
		component6.color = Color.white;
		component6.font = GUIManager.Instance.AveriaSerif;
		component6.fontSize = 18;
		component6.alignment = (TextAnchor)3;
	}

	private Sprite CreateCircleSprite()
	{
		Texture2D texture2D = new Texture2D(128, 128);
		Color[] array = new Color[16384];
		for (int i = 0; i < 128; i++)
		{
			for (int j = 0; j < 128; j++)
			{
				float num = Vector2.Distance(new Vector2(j, i), new Vector2(64f, 64f));
				array[i * 128 + j] = ((num < 64f) ? Color.white : Color.clear);
			}
		}
		texture2D.SetPixels(array);
		texture2D.Apply();
		return Sprite.Create(texture2D, new Rect(0f, 0f, 128f, 128f), new Vector2(0.5f, 0.5f));
	}

	private Sprite CreateRectangleSprite()
	{
		Texture2D texture2D = new Texture2D(128, 128);
		Color[] array = new Color[16384];
		for (int i = 0; i < array.Length; i++)
		{
			array[i] = Color.white;
		}
		texture2D.SetPixels(array);
		texture2D.Apply();
		return Sprite.Create(texture2D, new Rect(0f, 0f, 128f, 128f), new Vector2(0.5f, 0.5f));
	}

	private Sprite CreateCheckmarkSprite()
	{
		Texture2D texture2D = new Texture2D(128, 128);
		Color[] array = new Color[16384];
		for (int i = 0; i < 128; i++)
		{
			for (int j = 0; j < 128; j++)
			{
				if ((j > i - 30 && j < i + 10 && i > 64) || (j > 128 - i - 30 && j < 128 - i + 10 && i < 64))
				{
					array[i * 128 + j] = Color.white;
				}
				else
				{
					array[i * 128 + j] = Color.clear;
				}
			}
		}
		texture2D.SetPixels(array);
		texture2D.Apply();
		return Sprite.Create(texture2D, new Rect(0f, 0f, 128f, 128f), new Vector2(0.5f, 0.5f));
	}

	private static T SphereSearchForGameObjectWithComponent<T>(Vector3 p, float radius) where T : Component
	{
		int layerMask = -1;
		Collider[] array = Physics.OverlapSphere(p, radius, layerMask, QueryTriggerInteraction.Collide);
		List<T> list = new List<T>();
		Collider[] array2 = array;
		foreach (Collider collider in array2)
		{
			T componentInParentOrSelf = GetComponentInParentOrSelf<T>(collider.gameObject);
			if (componentInParentOrSelf != null)
			{
				list.Add(componentInParentOrSelf);
			}
		}
		if (list.Count > 0)
		{
			return list.OrderBy((T go) => go.transform.position.DistanceTo(p)).First();
		}
		return null;
	}

	private static List<T> SphereSearchForGameObjectsWithComponent<T>(Vector3 p, float radius) where T : Component
	{
		int layerMask = -1;
		Collider[] array = Physics.OverlapSphere(p, radius, layerMask, QueryTriggerInteraction.Collide);
		List<T> list = new List<T>();
		Collider[] array2 = array;
		foreach (Collider collider in array2)
		{
			T componentInParentOrSelf = GetComponentInParentOrSelf<T>(collider.gameObject);
			if (componentInParentOrSelf != null)
			{
				list.Add(componentInParentOrSelf);
			}
		}
		return list;
	}

	private static void SphereSearchForGameObjects(Vector3 p, float radius)
	{
		int layerMask = -1;
		Collider[] array = Physics.OverlapSphere(p, radius, layerMask, QueryTriggerInteraction.Collide);
		Collider[] array2 = array;
		foreach (Collider collider in array2)
		{
			GameObject gameObject = collider.gameObject;
			Character componentInParentOrSelf = GetComponentInParentOrSelf<Character>(gameObject);
			ItemDrop componentInParentOrSelf2 = GetComponentInParentOrSelf<ItemDrop>(gameObject);
			TreeBase componentInParentOrSelf3 = GetComponentInParentOrSelf<TreeBase>(gameObject);
			Pickable componentInParentOrSelf4 = GetComponentInParentOrSelf<Pickable>(gameObject);
			if (componentInParentOrSelf != null)
			{
				if (!componentInParentOrSelf.IsPlayer())
				{
					Debug.Log("Character detected: " + componentInParentOrSelf.name + " (Type: " + componentInParentOrSelf.GetHoverName() + ")");
				}
			}
			else if (componentInParentOrSelf2 != null)
			{
				Debug.Log("Item drop detected: " + componentInParentOrSelf2.name + " (Item: " + componentInParentOrSelf2.m_itemData.m_dropPrefab.name + ")");
			}
			else if (componentInParentOrSelf3 != null)
			{
				Debug.Log("Tree detected: " + componentInParentOrSelf3.name);
			}
			else if (componentInParentOrSelf4 != null)
			{
				Debug.Log("Pickable object detected: " + componentInParentOrSelf4.name);
			}
		}
	}

	private static GameObject PerformRaycast(Character player)
	{
		Vector3 eyePoint = player.GetEyePoint();
		Vector3 lookDir = player.GetLookDir();
		float maxDistance = 50f;
		if (Physics.Raycast(eyePoint, lookDir, out var hitInfo, maxDistance))
		{
			GameObject gameObject = FindTopLevelObject(hitInfo.collider.gameObject);
			Debug.Log("raycast hit " + gameObject.name);
			return gameObject;
		}
		player.Message(MessageHud.MessageType.TopLeft, "Raycast didn't hit anything");
		return null;
	}

	public static bool IsStringEqual(string a, string b, bool bCleanKey = true)
	{
		if (bCleanKey)
		{
			return CleanKey(a).ToLower().Equals(CleanKey(b).ToLower());
		}
		return a.ToLower().Equals(b.ToLower());
	}

	public static bool IsStringStartingWith(string a, string b, bool bCleanKey)
	{
		if (bCleanKey)
		{
			return CleanKey(a).ToLower().StartsWith(CleanKey(b).ToLower());
		}
		return a.ToLower().StartsWith(b.ToLower());
	}

	public static bool DoesStringContains(string a, string b, bool bCleanKey)
	{
		if (bCleanKey)
		{
			return CleanKey(a).ToLower().Contains(CleanKey(b).ToLower());
		}
		return a.ToLower().StartsWith(b.ToLower());
	}

	public static string CleanKey(string key)
	{
		int num = key.LastIndexOf('(');
		if (num != -1)
		{
			key = key.Substring(0, num);
		}
		key = key.Trim();
		return key;
	}

	private static string RemoveCustomText(string text)
	{
		string[] array = text.Split('\n');
		List<string> list = new List<string>();
		string[] array2 = array;
		foreach (string text2 in array2)
		{
			if (!text2.Contains("<color=orange>") && !text2.Contains("<color=purple>"))
			{
				list.Add(text2);
			}
		}
		return string.Join("\n", list);
	}

	private static float DistanceBetween(GameObject a, GameObject b)
	{
		return a.transform.position.DistanceTo(b.transform.position);
	}

	private static float CalculateXYDistance(Vector3 point1, Vector3 point2)
	{
		float num = point2.x - point1.x;
		float num2 = point2.y - point1.y;
		return Mathf.Sqrt(num * num + num2 * num2);
	}

	private static GameObject GetClosestFromArray(GameObject[] gos, Vector3 position)
	{
		return gos.OrderBy((GameObject go) => Vector3.Distance(position, go.transform.position)).FirstOrDefault();
	}

	public void SetTimer(float duration, Action onComplete)
	{
		((MonoBehaviour)this).StartCoroutine(TimerCoroutine(duration, onComplete));
	}

	private IEnumerator TimerCoroutine(float duration, Action onComplete)
	{
		yield return new WaitForSeconds(duration);
		onComplete?.Invoke();
	}

	private static GameObject FindTopLevelObject(GameObject obj)
	{
		while (obj.transform.parent != null)
		{
			obj = obj.transform.parent.gameObject;
		}
		return obj;
	}

	public static bool HasAnyChildComponent(GameObject gameObject, List<Type> componentTypes)
	{
		Component[] components = gameObject.GetComponents<Component>();
		Component[] array = components;
		foreach (Component component in array)
		{
			Type type = component.GetType();
			foreach (Type componentType in componentTypes)
			{
				if (componentType.IsAssignableFrom(type))
				{
					return true;
				}
			}
		}
		return false;
	}

	public static Component GetParentFromChildComponent(GameObject gameObject, Type parentType)
	{
		Component[] components = gameObject.GetComponents<Component>();
		Component[] array = components;
		foreach (Component component in array)
		{
			Type type = component.GetType();
			if (parentType.IsAssignableFrom(type))
			{
				return component;
			}
		}
		return null;
	}

	private static T GetComponentInParentOrSelf<T>(GameObject obj) where T : Component
	{
		T val = obj.GetComponent<T>();
		if (val == null)
		{
			val = obj.GetComponentInParent<T>();
		}
		return val;
	}

	private T CopyComponent<T>(GameObject source, GameObject destination) where T : Component
	{
		T component = source.GetComponent<T>();
		if (component != null)
		{
			T component2 = destination.GetComponent<T>();
			FieldInfo[] fields = typeof(T).GetFields();
			FieldInfo[] array = fields;
			foreach (FieldInfo fieldInfo in array)
			{
				fieldInfo.SetValue(component2, fieldInfo.GetValue(component));
			}
			return component2;
		}
		return null;
	}

	private static T GetComponentFromGameObject<T>(GameObject go) where T : Component
	{
		if (go == null)
		{
			return null;
		}
		Component parentFromChildComponent = GetParentFromChildComponent(go, typeof(T));
		if (parentFromChildComponent is T result)
		{
			return result;
		}
		return null;
	}

	private static Character GetCharacterFromGameObject(GameObject go)
	{
		if (go == null)
		{
			return null;
		}
		Component parentFromChildComponent = GetParentFromChildComponent(go, typeof(Character));
		if ((bool)parentFromChildComponent && parentFromChildComponent is Character)
		{
			return parentFromChildComponent as Character;
		}
		return null;
	}

	public static string IndentJson(string json)
	{
		int num = 0;
		bool flag = false;
		StringBuilder stringBuilder = new StringBuilder();
		for (int i = 0; i < json.Length; i++)
		{
			char c = json[i];
			switch (c)
			{
			case '[':
			case '{':
				stringBuilder.Append(c);
				if (!flag)
				{
					stringBuilder.AppendLine();
					Indent(++num, stringBuilder);
				}
				break;
			case ']':
			case '}':
				if (!flag)
				{
					stringBuilder.AppendLine();
					Indent(--num, stringBuilder);
				}
				stringBuilder.Append(c);
				break;
			case ',':
				stringBuilder.Append(c);
				if (!flag)
				{
					stringBuilder.AppendLine();
					Indent(num, stringBuilder);
				}
				break;
			case ':':
				stringBuilder.Append(c);
				if (!flag)
				{
					stringBuilder.Append(" ");
				}
				break;
			case '"':
			{
				stringBuilder.Append(c);
				bool flag2 = false;
				int num2 = i;
				while (num2 > 0 && json[--num2] == '\\')
				{
					flag2 = !flag2;
				}
				if (!flag2)
				{
					flag = !flag;
				}
				break;
			}
			default:
				stringBuilder.Append(c);
				break;
			}
		}
		return stringBuilder.ToString();
	}

	private static void Indent(int count, StringBuilder sb)
	{
		for (int i = 0; i < count; i++)
		{
			sb.Append("    ");
		}
	}

	public static string Decrypt(string cipherText)
	{
		using Aes aes = Aes.Create();
		aes.Key = Key;
		aes.IV = IV;
		ICryptoTransform transform = aes.CreateDecryptor(aes.Key, aes.IV);
		using MemoryStream stream = new MemoryStream(Convert.FromBase64String(cipherText));
		using CryptoStream stream2 = new CryptoStream(stream, transform, CryptoStreamMode.Read);
		using StreamReader streamReader = new StreamReader(stream2);
		return streamReader.ReadToEnd();
	}

	private void DoModInit()
	{
		LogWarning("Initializing Thrall Mod!");
		Chat.instance.SendText(Talker.Type.Normal, "EGO.AI THRALL MOD LOADED!");
		CreateModMenuUI();
		NPCCurrentMode = NPCMode.Defensive;
		FindPlayerNPC();
		if ((bool)PlayerNPC)
		{
			HumanoidNPC component = PlayerNPC.GetComponent<HumanoidNPC>();
			LoadNPCData(component);
		}
		PopulateDatabase();
		ModInitComplete = true;
		LogMessage("Thrall mod initialization complete");
	}

	private void Awake()
	{
		logger = ((BaseUnityPlugin)this).Logger;
		instance = this;
		LogMessage("ego.ai Thrall ValheimAIModLivePatch Loaded! :)");
		LogWarning("This mod is designed for single-player gameplay and may not function correctly when used alongside other mods.");
		ConfigBindings();
		playerDialogueAudioPath = Path.Combine(Application.persistentDataPath, "playerdialogue.wav");
		npcDialogueAudioPath = Path.Combine(Application.persistentDataPath, "npcdialogue.wav");
		npcDialogueRawAudioPath = Path.Combine(Application.persistentDataPath, "npcdialogue_raw.wav");
		LogInfo("Setting up logging for Thrall");
		instance.RestartSendLogTimer();
		if (IsInAWorld())
		{
			instance.DoModInit();
		}
		else
		{
			LogWarning("Thrall mod loaded at startup. Mod not initalized yet! Waiting for player to join a world...");
		}
		harmony.PatchAll(typeof(ValheimAIModLivePatch));
	}

	private void ConfigBindings()
	{
		LogToBrain = ((BaseUnityPlugin)this).Config.Bind<bool>("Bool", "LogToBrain", true, "Log To Brain?");
		DisableAutoSave = ((BaseUnityPlugin)this).Config.Bind<bool>("Bool", "DisableAutoSave", false, "Disable auto saving the game world?");
		spawnKey = ((BaseUnityPlugin)this).Config.Bind<KeyCode>("Keybinds", "Spawn", KeyCode.G, "Key for spawning a Thrall");
		harvestKey = ((BaseUnityPlugin)this).Config.Bind<KeyCode>("Keybinds", "Harvest", KeyCode.H, "Key for spawning a Thrall");
		followKey = ((BaseUnityPlugin)this).Config.Bind<KeyCode>("Keybinds", "Follow", KeyCode.F, "Key for spawning a Thrall");
		talkKey = ((BaseUnityPlugin)this).Config.Bind<KeyCode>("Keybinds", "Talk", KeyCode.T, "Key for spawning a Thrall");
		inventoryKey = ((BaseUnityPlugin)this).Config.Bind<KeyCode>("Keybinds", "Inventory", KeyCode.E, "Key for spawning a Thrall");
		thrallMenuKey = ((BaseUnityPlugin)this).Config.Bind<KeyCode>("Keybinds", "Menu", KeyCode.Y, "Key for spawning a Thrall");
		combatModeKey = ((BaseUnityPlugin)this).Config.Bind<KeyCode>("Keybinds", "CombatMode", KeyCode.J, "Key for spawning a Thrall");
		allKeybinds = new List<ConfigEntry<KeyCode>> { instance.spawnKey, instance.harvestKey, instance.followKey, instance.inventoryKey, instance.talkKey, instance.thrallMenuKey, instance.combatModeKey };
	}

	private void OnDestroy()
	{
		if (panelManager != null)
		{
			panelManager.DestroyAllPanels();
		}
		if (!ZInput.GetKey(KeyCode.F6))
		{
			instance.SendLogToBrain();
		}
		harmony.UnpatchSelf();
	}

	private void OnUnload()
	{
		if (panelManager != null)
		{
			panelManager.DestroyAllPanels();
		}
	}

	private void PopulateDatabase()
	{
		foreach (GameObject prefab in ZNetScene.instance.m_prefabs)
		{
			if (ExposedGameObjectExtension.HasAnyComponent(prefab, new string[1] { "TreeBase" }))
			{
				CheckTreeBase(prefab);
			}
			if (ExposedGameObjectExtension.HasAnyComponent(prefab, new string[1] { "TreeLog" }))
			{
				CheckTreeLog(prefab);
			}
			if (ExposedGameObjectExtension.HasAnyComponent(prefab, new string[1] { "Pickable" }))
			{
				CheckPickables(prefab);
			}
			if (ExposedGameObjectExtension.HasAnyComponent(prefab, new string[1] { "ItemDrop" }))
			{
				CheckItemDrop(prefab);
			}
			if (ExposedGameObjectExtension.HasAnyComponent(prefab, new string[1] { "MineRock" }))
			{
				CheckMineRock(prefab);
			}
			if (ExposedGameObjectExtension.HasAnyComponent(prefab, new string[1] { "MineRock5" }))
			{
				CheckMineRock5(prefab);
			}
			if (ExposedGameObjectExtension.HasAnyComponent(prefab, new string[1] { "Destructible" }))
			{
				CheckDestructibles(prefab);
			}
			else if (ExposedGameObjectExtension.HasAnyComponent(prefab, new string[1] { "DropOnDestroyed" }))
			{
				CheckDropOnDestroyed(prefab);
			}
			if (ExposedGameObjectExtension.HasAnyComponent(prefab, new string[1] { "CharacterDrop" }))
			{
				CheckCharacterDrop(prefab);
			}
		}
		AddResourceRelationships();
	}

	private void AddResourceRelationships()
	{
		foreach (KeyValuePair<string, Dictionary<string, List<Resource>>> item in resourceDatabase)
		{
			Dictionary<string, List<Resource>> value = item.Value;
			List<Resource> list = new List<Resource>();
			list.AddRange(value["TreeLog"]);
			foreach (Resource item2 in value["TreeLog"])
			{
				if (logToLogMap.ContainsKey(item2.Name))
				{
					list.AddRange(logToLogMap[item2.Name]);
				}
			}
			resourceDatabase[item.Key]["TreeLog"] = list.ToList();
			list.Clear();
			list.AddRange(value["TreeBase"]);
			foreach (Resource item3 in value["TreeLog"])
			{
				if (logToTreeMap.ContainsKey(item3.Name))
				{
					list.AddRange(logToTreeMap[item3.Name]);
				}
			}
			resourceDatabase[item.Key]["TreeBase"] = list.ToList();
			list.Clear();
			list.AddRange(value["MineRock5"]);
			foreach (Resource item4 in value["MineRock5"])
			{
				if (destructibleToSpawnMap.ContainsKey(item4.Name))
				{
					list.AddRange(destructibleToSpawnMap[item4.Name]);
				}
			}
			resourceDatabase[item.Key]["MineRock5"] = list.ToList();
		}
	}

	private void CheckTreeBase(GameObject prefab)
	{
		TreeBase component = prefab.GetComponent<TreeBase>();
		if (!(component != null) || component.m_dropWhenDestroyed == null || component.m_dropWhenDestroyed.m_drops == null)
		{
			return;
		}
		foreach (DropTable.DropData drop in component.m_dropWhenDestroyed.m_drops)
		{
			float value = -1f;
			if (resourceHealthMap.TryGetValue(prefab.name, out value))
			{
				resourceHealthMap[prefab.name] = Math.Max(component.m_health, value);
			}
			else
			{
				resourceHealthMap[prefab.name] = component.m_health;
			}
			resourceQuantityMap[prefab.name] = component.m_dropWhenDestroyed.m_dropMax;
			Resource sourceResource = new Resource(prefab.name, component.m_dropWhenDestroyed.m_dropMin, component.m_dropWhenDestroyed.m_dropMax, resourceHealthMap[prefab.name], component.m_damageModifiers);
			AddToDatabase(drop.m_item.name, "TreeBase", sourceResource);
		}
		if (component.m_logPrefab != null)
		{
			TreeLog component2 = component.m_logPrefab.GetComponent<TreeLog>();
			TreeLog treeLog = null;
			if ((bool)component2 && (bool)component2.m_subLogPrefab)
			{
				treeLog = component2.m_subLogPrefab.GetComponent<TreeLog>();
			}
			int minAmount = ((!treeLog) ? 1 : ((int)((float)treeLog.m_dropWhenDestroyed.m_dropMin * 0.6f)));
			int maxAmount = ((!treeLog) ? 1 : ((int)((float)treeLog.m_dropWhenDestroyed.m_dropMax * 0.6f)));
			Resource resource = new Resource(prefab.name, minAmount, maxAmount, component.m_health, component.m_damageModifiers);
			AddToDatabase(component.m_logPrefab.name, "TreeBase", resource);
			if (!logToTreeMap.ContainsKey(component.m_logPrefab.name))
			{
				logToTreeMap[component.m_logPrefab.name] = new List<Resource>();
			}
			logToTreeMap[component.m_logPrefab.name].Add(resource);
		}
	}

	private void CheckTreeLog(GameObject prefab)
	{
		TreeLog component = prefab.GetComponent<TreeLog>();
		if (!(component != null) || component.m_dropWhenDestroyed == null || component.m_dropWhenDestroyed.m_drops == null)
		{
			return;
		}
		foreach (DropTable.DropData drop in component.m_dropWhenDestroyed.m_drops)
		{
			float value = -1f;
			if (resourceHealthMap.TryGetValue(prefab.name, out value))
			{
				resourceHealthMap[prefab.name] = Math.Max(component.m_health, value);
			}
			else
			{
				resourceHealthMap[prefab.name] = component.m_health;
			}
			resourceQuantityMap[prefab.name] = component.m_dropWhenDestroyed.m_dropMax;
			Resource sourceResource = new Resource(prefab.name, component.m_dropWhenDestroyed.m_dropMin, component.m_dropWhenDestroyed.m_dropMax, resourceHealthMap[prefab.name], component.m_damages);
			AddToDatabase(drop.m_item.name, "TreeLog", sourceResource);
		}
		if (component.m_subLogPrefab != null)
		{
			TreeLog component2 = component.m_subLogPrefab.GetComponent<TreeLog>();
			int minAmount = ((!component2) ? 1 : ((int)((float)component2.m_dropWhenDestroyed.m_dropMin * 0.8f)));
			int maxAmount = ((!component2) ? 1 : ((int)((float)component2.m_dropWhenDestroyed.m_dropMax * 0.8f)));
			Resource resource = new Resource(prefab.name, minAmount, maxAmount, component.m_health, component.m_damages);
			AddToDatabase(component.m_subLogPrefab.name, "TreeLog", resource);
			if (!logToLogMap.ContainsKey(component.m_subLogPrefab.name))
			{
				logToLogMap[component.m_subLogPrefab.name] = new List<Resource>();
			}
			logToLogMap[component.m_subLogPrefab.name].Add(resource);
		}
	}

	private void CheckCharacterDrop(GameObject prefab)
	{
		CharacterDrop component = prefab.GetComponent<CharacterDrop>();
		HitData.DamageModifiers damageModifiers = default(HitData.DamageModifiers);
		if (!(component != null) || component.m_drops == null)
		{
			return;
		}
		float value = -1f;
		if (ExposedGameObjectExtension.HasAnyComponent(prefab, new string[1] { "Humanoid" }))
		{
			Humanoid component2 = prefab.GetComponent<Humanoid>();
			damageModifiers = component2.m_damageModifiers;
			if (resourceHealthMap.TryGetValue(prefab.name, out value))
			{
				resourceHealthMap[prefab.name] = Math.Max(component2.m_health, value);
			}
			else
			{
				resourceHealthMap[prefab.name] = component2.m_health;
			}
		}
		else if (ExposedGameObjectExtension.HasAnyComponent(prefab, new string[1] { "Character" }))
		{
			Character component3 = prefab.GetComponent<Character>();
			damageModifiers = component3.m_damageModifiers;
			if (resourceHealthMap.TryGetValue(prefab.name, out value))
			{
				resourceHealthMap[prefab.name] = Math.Max(component3.m_health, value);
			}
			else
			{
				resourceHealthMap[prefab.name] = component3.m_health;
			}
		}
		foreach (CharacterDrop.Drop drop in component.m_drops)
		{
			resourceQuantityMap[prefab.name] = component.m_drops.Count;
			Resource sourceResource = new Resource(prefab.name, drop.m_amountMin, drop.m_amountMax, resourceHealthMap[prefab.name], damageModifiers);
			AddToDatabase(drop.m_prefab.name, "CharacterDrop", sourceResource);
		}
	}

	private void CheckDropOnDestroyed(GameObject prefab)
	{
		DropOnDestroyed component = prefab.GetComponent<DropOnDestroyed>();
		HitData.DamageModifiers damageModifiers = default(HitData.DamageModifiers);
		if (!(component != null) || component.m_dropWhenDestroyed == null || component.m_dropWhenDestroyed.m_drops == null)
		{
			return;
		}
		float value = -1f;
		if (resourceHealthMap.TryGetValue(prefab.name, out value))
		{
			resourceHealthMap[prefab.name] = value;
		}
		else
		{
			resourceHealthMap[prefab.name] = value;
			if (resourceHealthMap[prefab.name] <= 0f && ExposedGameObjectExtension.HasAnyComponent(prefab, new string[1] { "WearNTear" }))
			{
				WearNTear component2 = prefab.GetComponent<WearNTear>();
				if (component2 != null)
				{
					resourceHealthMap[prefab.name] = component2.m_health;
					damageModifiers = component2.m_damages;
				}
			}
		}
		foreach (DropTable.DropData drop in component.m_dropWhenDestroyed.m_drops)
		{
			resourceQuantityMap[prefab.name] = component.m_dropWhenDestroyed.m_dropMax;
			Resource sourceResource = new Resource(prefab.name, component.m_dropWhenDestroyed.m_dropMin, component.m_dropWhenDestroyed.m_dropMax, resourceHealthMap[prefab.name], damageModifiers);
			if ((bool)drop.m_item)
			{
				AddToDatabase(drop.m_item.name, "DropOnDestroyed", sourceResource);
			}
		}
	}

	private void CheckItemDrop(GameObject prefab)
	{
		ItemDrop component = prefab.GetComponent<ItemDrop>();
		if (component != null && component.m_itemData != null)
		{
			resourceQuantityMap[prefab.name] = component.m_itemData.m_stack;
			Resource sourceResource = new Resource(prefab.name, 1, component.m_itemData.m_stack, 2.5f);
			AddToDatabase(prefab.name, "ItemDrop", sourceResource);
		}
	}

	private void CheckDestructibles(GameObject prefab)
	{
		Destructible component = prefab.GetComponent<Destructible>();
		if (!(component != null))
		{
			return;
		}
		float value = -1f;
		if (resourceHealthMap.TryGetValue(prefab.name, out value))
		{
			resourceHealthMap[prefab.name] = Math.Max(component.m_health, value);
		}
		else
		{
			resourceHealthMap[prefab.name] = component.m_health;
		}
		resourceQuantityMap[prefab.name] = 1f;
		int minAmount = 1;
		int maxAmount = 1;
		DropOnDestroyed component2 = prefab.GetComponent<DropOnDestroyed>();
		if (component2 != null && component2.m_dropWhenDestroyed != null)
		{
			foreach (DropTable.DropData drop in component2.m_dropWhenDestroyed.m_drops)
			{
				resourceQuantityMap[prefab.name] = component2.m_dropWhenDestroyed.m_dropMax;
				minAmount = component2.m_dropWhenDestroyed.m_dropMin;
				maxAmount = component2.m_dropWhenDestroyed.m_dropMax;
				Resource sourceResource = new Resource(prefab.name, minAmount, maxAmount, resourceHealthMap[prefab.name], component.m_damages);
				if ((bool)drop.m_item)
				{
					AddToDatabase(drop.m_item.name, "Destructible", sourceResource);
				}
			}
		}
		if (component.m_spawnWhenDestroyed != null)
		{
			Resource item = new Resource(prefab.name, minAmount, maxAmount, component.m_health, component.m_damages);
			if (!destructibleToSpawnMap.ContainsKey(component.m_spawnWhenDestroyed.name))
			{
				destructibleToSpawnMap[component.m_spawnWhenDestroyed.name] = new List<Resource>();
			}
			destructibleToSpawnMap[component.m_spawnWhenDestroyed.name].Add(item);
		}
	}

	private void CheckPickables(GameObject prefab)
	{
		Pickable component = prefab.GetComponent<Pickable>();
		if (component != null && component.m_itemPrefab != null)
		{
			resourceQuantityMap[prefab.name] = component.m_amount;
			Resource sourceResource = new Resource(prefab.name, component.m_amount, component.m_amount, 2.5f);
			AddToDatabase(component.m_itemPrefab.name, "Pickable", sourceResource);
		}
	}

	private void CheckMineRock(GameObject prefab)
	{
		MineRock component = prefab.GetComponent<MineRock>();
		if (!(component != null) || component.m_dropItems == null || component.m_dropItems.m_drops == null)
		{
			return;
		}
		float value = -1f;
		if (resourceHealthMap.TryGetValue(prefab.name, out value))
		{
			resourceHealthMap[prefab.name] = Math.Max(component.m_health, value);
		}
		else
		{
			resourceHealthMap[prefab.name] = component.m_health;
		}
		resourceQuantityMap[prefab.name] = component.m_dropItems.m_dropMax;
		foreach (DropTable.DropData drop in component.m_dropItems.m_drops)
		{
			Resource sourceResource = new Resource(prefab.name, drop.m_stackMin, drop.m_stackMax, resourceHealthMap[prefab.name], component.m_damageModifiers);
			AddToDatabase(drop.m_item.name, "MineRock", sourceResource);
		}
	}

	private void CheckMineRock5(GameObject prefab)
	{
		MineRock5 component = prefab.GetComponent<MineRock5>();
		if (!(component != null) || component.m_dropItems == null || component.m_dropItems.m_drops == null)
		{
			return;
		}
		float value = -1f;
		if (resourceHealthMap.TryGetValue(prefab.name, out value))
		{
			resourceHealthMap[prefab.name] = Math.Max(component.m_health, value);
		}
		else
		{
			resourceHealthMap[prefab.name] = component.m_health;
		}
		resourceQuantityMap[prefab.name] = component.m_dropItems.m_dropMax;
		foreach (DropTable.DropData drop in component.m_dropItems.m_drops)
		{
			Resource sourceResource = new Resource(prefab.name, drop.m_stackMin, drop.m_stackMax, resourceHealthMap[prefab.name], component.m_damageModifiers);
			AddToDatabase(drop.m_item.name, "MineRock5", sourceResource);
		}
	}

	private void AddToDatabase(string resourceName, string sourceType, Resource sourceResource)
	{
		if (!resourceDatabase.ContainsKey(resourceName))
		{
			resourceDatabase[resourceName] = new Dictionary<string, List<Resource>>
			{
				{
					"TreeLog",
					new List<Resource>()
				},
				{
					"TreeBase",
					new List<Resource>()
				},
				{
					"MineRock",
					new List<Resource>()
				},
				{
					"MineRock5",
					new List<Resource>()
				},
				{
					"DropOnDestroyed",
					new List<Resource>()
				},
				{
					"Destructible",
					new List<Resource>()
				},
				{
					"ItemDrop",
					new List<Resource>()
				},
				{
					"Pickable",
					new List<Resource>()
				},
				{
					"CharacterDrop",
					new List<Resource>()
				}
			};
		}
		resourceDatabase[resourceName][sourceType].Add(sourceResource);
	}

	private void SaveDatabaseToJson()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Expected O, but got Unknown
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Expected O, but got Unknown
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Expected O, but got Unknown
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Expected O, but got Unknown
		JsonObject val = new JsonObject();
		foreach (KeyValuePair<string, Dictionary<string, List<Resource>>> item in resourceDatabase)
		{
			JsonObject val2 = new JsonObject();
			foreach (KeyValuePair<string, List<Resource>> item2 in item.Value)
			{
				JsonArray val3 = new JsonArray();
				foreach (Resource item3 in item2.Value)
				{
					JsonObject val4 = new JsonObject();
					val4["Name"] = item3.Name;
					val4["MinAmount"] = item3.MinAmount;
					val4["MaxAmount"] = item3.MaxAmount;
					val4["Health"] = item3.Health;
					val4["DamageModifiers"] = item3.DamageModifiers;
					((List<object>)(object)val3).Add((object)val4);
				}
				val2[item2.Key] = val3;
			}
			val[item.Key] = val2;
		}
		string text = Path.Combine(Application.persistentDataPath, "resource_database.json");
		File.WriteAllText(text, IndentJson(((object)val).ToString()));
		LogInfo("Saved resource database to " + text);
	}

	private List<(string Category, string Name, float Efficiency, float Distance, int Depth)> FindResourceSourcesRecursive(string resource, ItemDrop.ItemData weapon, int depth = 0, int maxDepth = 3)
	{
		List<(string, string, float, float, int)> list = new List<(string, string, float, float, int)>();
		if (!resourceDatabase.ContainsKey(resource))
		{
			return list;
		}
		GetNearbyResources(Player.m_localPlayer.gameObject);
		foreach (KeyValuePair<string, List<Resource>> item2 in resourceDatabase[resource])
		{
			foreach (Resource item3 in item2.Value)
			{
				if (nearbyResourcesDistance.TryGetValue(item3.Name, out var value))
				{
					float weaponEffectiveness = CalculateWeaponEffectiveness(weapon, item3.DamageModifiers);
					float item = CalculateEfficiency(item3.Name, item2.Key, item3.MinAmount, item3.MaxAmount, item3.Health, weaponEffectiveness, value);
					list.Add((item2.Key, item3.Name, item, value, depth));
				}
			}
		}
		return list;
	}

	public static Dictionary<string, List<Resource>> QueryResourceComplete(string resourceName, bool HasWeapon = true)
	{
		if (!resourceDatabase.ContainsKey(resourceName))
		{
			return new Dictionary<string, List<Resource>>();
		}
		Dictionary<string, List<Resource>> dictionary = resourceDatabase[resourceName];
		Dictionary<string, List<Resource>> dictionary2 = new Dictionary<string, List<Resource>>();
		foreach (string item in HasWeapon ? priorityOrder : priorityOrderUnarmed)
		{
			if (dictionary.ContainsKey(item))
			{
				dictionary2[item] = dictionary[item];
			}
		}
		return dictionary2;
	}

	private static List<List<string>> ConvertResourcesToNames(List<List<Resource>> resourceLists)
	{
		return resourceLists.Select((List<Resource> innerList) => innerList.Select((Resource resource) => resource.Name).ToList()).ToList();
	}

	private static List<string> FlattenListOfLists(List<List<string>> nestedList)
	{
		return nestedList.SelectMany((List<string> innerList) => innerList).ToList();
	}

	private void PopulateCraftingRequirements()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Expected O, but got Unknown
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Expected O, but got Unknown
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Expected O, but got Unknown
		//IL_0207: Unknown result type (might be due to invalid IL or missing references)
		//IL_020e: Expected O, but got Unknown
		//IL_0228: Unknown result type (might be due to invalid IL or missing references)
		//IL_022f: Expected O, but got Unknown
		JsonObject val = new JsonObject();
		foreach (GameObject item in ObjectDB.instance.m_items)
		{
			ItemDrop component = item.GetComponent<ItemDrop>();
			if (!(component != null))
			{
				continue;
			}
			JsonObject val2 = new JsonObject();
			val2["name"] = component.name;
			val2["itemName"] = component.m_itemData.m_shared.m_name;
			JsonObject val3 = new JsonObject();
			foreach (KeyValuePair<string, string> customDatum in component.m_itemData.m_customData)
			{
				val3[customDatum.Key] = customDatum.Value;
			}
			if (val3.Count > 0)
			{
				val2["customData"] = val3;
			}
			if (component.m_itemData.m_shared.m_description != "")
			{
				string text = LocalizationManager.Instance.TryTranslate(component.m_itemData.m_shared.m_description);
				if (text != "")
				{
					val2["description"] = text;
				}
			}
			val2["armor"] = component.m_itemData.m_shared.m_armor;
			val2["maxDurability"] = component.m_itemData.m_shared.m_maxDurability;
			val2["weight"] = component.m_itemData.m_shared.m_weight;
			Recipe recipe = ObjectDB.instance.GetRecipe(component.m_itemData);
			if (recipe != null)
			{
				craftingRequirements[component.m_itemData.m_shared.m_name] = recipe.m_resources;
				JsonArray val4 = new JsonArray();
				Piece.Requirement[] resources = recipe.m_resources;
				foreach (Piece.Requirement requirement in resources)
				{
					JsonObject val5 = new JsonObject();
					val5["name"] = requirement.m_resItem.name;
					val5["itemName"] = requirement.m_resItem.m_itemData.m_shared.m_name;
					if (requirement.m_resItem.m_itemData.m_shared.m_description != "")
					{
						string text2 = LocalizationManager.Instance.TryTranslate(requirement.m_resItem.m_itemData.m_shared.m_description);
						if (text2 != "")
						{
							val5["description"] = text2;
						}
					}
					val5["amount"] = requirement.m_amount;
					((List<object>)(object)val4).Add((object)val5);
				}
				val2["m_resources"] = val4;
			}
			val[component.m_itemData.m_shared.m_name] = val2;
		}
		string contents = IndentJson(((object)val).ToString());
		string text3 = Path.Combine(Application.persistentDataPath, "crafting_requirements.json");
		File.WriteAllText(text3, contents);
		LogError("Crafting requirements exported to " + text3);
	}

	private void PopulateBuildingRequirements()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Expected O, but got Unknown
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Expected O, but got Unknown
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_0168: Expected O, but got Unknown
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_0189: Expected O, but got Unknown
		JsonObject val = new JsonObject();
		foreach (GameObject prefab in ZNetScene.instance.m_prefabs)
		{
			Piece component = prefab.GetComponent<Piece>();
			if (!(component != null))
			{
				continue;
			}
			string name = component.m_name;
			buildingRequirements[name] = component.m_resources;
			JsonObject val2 = new JsonObject();
			val2["name"] = component.name;
			val2["itemName"] = component.m_name;
			if (component.m_description != "")
			{
				string text = LocalizationManager.Instance.TryTranslate(component.m_description);
				if (text != "")
				{
					val2["description"] = text;
				}
			}
			val2["category"] = component.m_category.ToString();
			val2["comfort"] = component.m_comfort;
			val2["groundPiece"] = component.m_groundPiece;
			val2["allowedInDungeons"] = component.m_allowedInDungeons;
			val2["spaceRequirement"] = component.m_spaceRequirement;
			JsonArray val3 = new JsonArray();
			Piece.Requirement[] resources = component.m_resources;
			foreach (Piece.Requirement requirement in resources)
			{
				JsonObject val4 = new JsonObject();
				val4["name"] = requirement.m_resItem.name;
				val4["itemName"] = requirement.m_resItem.m_itemData.m_shared.m_name;
				if (requirement.m_resItem.m_itemData.m_shared.m_description != "")
				{
					string text2 = LocalizationManager.Instance.TryTranslate(requirement.m_resItem.m_itemData.m_shared.m_description);
					if (text2 != "")
					{
						val4["description"] = text2;
					}
				}
				val4["amount"] = requirement.m_amount;
				val4["amountPerLevel"] = requirement.m_amountPerLevel;
				val4["m_recover"] = requirement.m_recover;
				val4["m_extraAmountOnlyOneIngredient"] = requirement.m_extraAmountOnlyOneIngredient;
				((List<object>)(object)val3).Add((object)val4);
			}
			val2["m_resources"] = val3;
			val[name] = val2;
		}
		string contents = IndentJson(((object)val).ToString());
		string text3 = Path.Combine(Application.persistentDataPath, "building_requirements.json");
		File.WriteAllText(text3, contents);
		LogError("Building requirements exported to " + text3);
	}

	private void PopulateMonsterPrefabs()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Expected O, but got Unknown
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Expected O, but got Unknown
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Expected O, but got Unknown
		JsonArray val = new JsonArray();
		foreach (GameObject prefab in ZNetScene.instance.m_prefabs)
		{
			Character component = prefab.GetComponent<Character>();
			Humanoid component2 = prefab.GetComponent<Humanoid>();
			if (component != null)
			{
				JsonObject val2 = new JsonObject();
				val2["name"] = component.name;
				val2["itemName"] = component.m_name;
				((List<object>)(object)val).Add((object)val2);
			}
			if (component2 != null)
			{
				JsonObject val3 = new JsonObject();
				val3["name"] = component2.name;
				val3["itemName"] = component2.m_name;
				((List<object>)(object)val).Add((object)val3);
			}
		}
		string json = ((object)val).ToString();
		json = IndentJson(json);
		string text = Path.Combine(Application.persistentDataPath, "monsters.json");
		File.WriteAllText(text, json);
		LogError("Monster prefab list exported to " + text);
	}

	private void PopulateAllItems()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Expected O, but got Unknown
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Expected O, but got Unknown
		JsonArray val = new JsonArray();
		foreach (GameObject prefab in ZNetScene.instance.m_prefabs)
		{
			if (ExposedGameObjectExtension.HasAnyComponent(prefab, new string[1] { "ItemDrop" }))
			{
				JsonObject val2 = new JsonObject();
				ItemDrop component = prefab.GetComponent<ItemDrop>();
				val2["name"] = prefab.name;
				val2["shared"] = component.m_itemData.m_shared.ToString();
				((List<object>)(object)val).Add((object)val2);
			}
		}
		string json = ((object)val).ToString();
		json = IndentJson(json);
		string text = Path.Combine(Application.persistentDataPath, "all_items_list.json");
		File.WriteAllText(text, json);
		LogError("all_items_list exported to " + text);
	}

	private void PopulateAllWeapons()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Expected O, but got Unknown
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Expected O, but got Unknown
		JsonObject val = new JsonObject();
		foreach (GameObject prefab in ZNetScene.instance.m_prefabs)
		{
			if (ExposedGameObjectExtension.HasAnyComponent(prefab, new string[1] { "ItemDrop" }))
			{
				ItemDrop component = prefab.GetComponent<ItemDrop>();
				if ((bool)component && component.m_itemData.IsWeapon())
				{
					JsonObject val2 = new JsonObject();
					val2["Durability"] = component.m_itemData.m_durability;
					val2["Quality"] = component.m_itemData.m_quality;
					val2["m_aiAttackRange"] = component.m_itemData.m_shared.m_aiAttackRange;
					val2["Weight"] = component.m_itemData.m_shared.m_weight;
					val2["Attack"] = component.m_itemData.m_shared.m_attack.m_attackAnimation;
					val2["SecondaryAttack"] = component.m_itemData.m_shared.m_secondaryAttack.m_attackAnimation;
					val2["DamageModifiers"] = component.m_itemData.m_shared.m_damages;
					val2["DamagesPerLevel"] = component.m_itemData.m_shared.m_damagesPerLevel;
					val[prefab.name] = val2;
				}
			}
		}
		string json = ((object)val).ToString();
		json = IndentJson(json);
		string text = Path.Combine(Application.persistentDataPath, "all_weapons.json");
		File.WriteAllText(text, json);
		LogError("All weapons exported to " + text);
	}

	public Piece.Requirement[] GetCraftingRequirements(string itemName)
	{
		if (craftingRequirements.ContainsKey(itemName))
		{
			return craftingRequirements[itemName];
		}
		return null;
	}
}
